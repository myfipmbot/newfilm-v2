const {
    default: makeWASocket,
    generateWAMessageFromContent,
    prepareWAMessageMedia,
    proto
} = require('@whiskeysockets/baileys')

const config = require('../settings')
const fg = require('api-dylux');
const apkdl = require('../lib/apkdl')
const { mediafireDl } = require('mfiredlcore-vihangayt')
const { cmd, commands } = require('../lib/command')
const { Download } = require("nima-threads-dl-api")
const { getBuffer, getFile, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson, jsonformat} = require('../lib/functions')
const { pinterest, wallpaper, wikimedia, quotesAnime, aiovideodl, umma, ringtone, styletext } = require('../lib/scraper')
const gis = require('async-g-i-s')
const axios = require('axios');
const cheerio = require('cheerio');
const puppeteer = require('puppeteer');
const vm = require('vm')
const { facebook } = require('@mrnima/facebook-downloader');
const { downloadTiktok } = require("@mrnima/tiktok-downloader");
const yts = require('yt-search');
const FormData = require('form-data')
const videoSearchResults = new Map()
var request = require("request")
let currentPollIndex = 0
let optionIndex = 1;
const fs = require('fs');
const {unsplash, pixabay} = require("@sl-code-lords/image-library")
var {subsearch , subdl }  = require('@sl-code-lords/si-subdl')
var uploader = "ùôÜùòºùôëùôÑ ùôÄùôìùôÄ üêãüíó "
const { sizeFormatter} = require('human-readable');
const { File } = require('megajs')
const { Tiktok } = require('../lib/tiktok')
function regtik(url) {return url.includes('tiktok.com')}
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args))
async function fbDownloader(url) {
	try {
		const response1 = await axios({
			method: 'POST',
			url: 'https://snapsave.app/action.php?lang=vn',
			headers: {
				"accept": "*/*",
				"accept-language": "vi,en-US;q=0.9,en;q=0.8",
				"content-type": "multipart/form-data",
				"sec-ch-ua": "\"Chromium\";v=\"110\", \"Not A(Brand\";v=\"24\", \"Microsoft Edge\";v=\"110\"",
				"sec-ch-ua-mobile": "?0",
				"sec-ch-ua-platform": "\"Windows\"",
				"sec-fetch-dest": "empty",
				"sec-fetch-mode": "cors",
				"sec-fetch-site": "same-origin",
				"Referer": "https://snapsave.app/vn",
				"Referrer-Policy": "strict-origin-when-cross-origin"
			},
			data: {
				url
			}
		});

		let html;
		const evalCode = response1.data.replace('return decodeURIComponent', 'html = decodeURIComponent')
		eval(evalCode);
		html = html.split('innerHTML = "')[1].split('";\n')[0].replace(/\\"/g, '"')

		const $ = cheerio.load(html)
		const download = []

		const tbody = $('table').find('tbody')
		const trs = tbody.find('tr')

		trs.each(function (i, elem) {
			const trElement = $(elem)
			const tds = trElement.children()
			const quality = $(tds[0]).text().trim()
			const url = $(tds[2]).children('a').attr('href')
			if (url != undefined) {
				download.push({
					quality,
					url
				});
			}
		});

		return {
			success: true,
			download
		};
	}
	catch (err) {
		return {
			success: false
		};
	}
}
function fbreg(url) {
const fbRegex = /(?:https?:\/\/)?(?:www\.)?(m\.facebook|facebook|fb)\.(com|me|watch)\/(?:(?:\w\.)*#!\/)?(?:groups\/)?(?:[\w\-\.]*\/)*([\w\-\.]*)/
return fbRegex.test(url)
}

//============================================================================

async function Insta(match) {
  const result = []
          const form = {
            url: match,
            submit: '',
          }
          const { data } = await axios(`https://downloadgram.org/`, {
            method: 'POST',
            data: form
          })
          const $ = cheerio.load(data)
                  $('#downloadhere > a').each(function (a,b) {
          const url = $(b).attr('href')
          if (url) result.push(url)
        })
              return result
  }

//============================================================================

async function sswebA(url = '', full = false, type = 'desktop') {
	type = type.toLowerCase()
	if (!['desktop', 'tablet', 'phone'].includes(type)) type = 'desktop'
	let form = new URLSearchParams()
	form.append('url', url)
	form.append('device', type)
	if (!!full) form.append('full', 'on')
	form.append('cacheLimit', 0)
	let res = await axios({
		url: 'https://www.screenshotmachine.com/capture.php',
		method: 'post',
		data: form
	})
	let cookies = res.headers['set-cookie']
	let buffer = await axios({
		url: 'https://www.screenshotmachine.com/' + res.data.link,
		headers: {
			'cookie': cookies.join('')
		},
		responseType: 'arraybuffer' 
	})
	return Buffer.from(buffer.data)
}



function formatUploadDate(uploadDate) {
  const date = new Date(uploadDate);
  return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
}



let soundcloud = async (link) => {
	return new Promise((resolve, reject) => {
		const options = {
			method: 'POST',
			url: "https://www.klickaud.co/download.php",
			headers: {
				'content-type': 'application/x-www-form-urlencoded'
			},
			formData: {
				'value': link,
				'2311a6d881b099dc3820600739d52e64a1e6dcfe55097b5c7c649088c4e50c37': '710c08f2ba36bd969d1cbc68f59797421fcf90ca7cd398f78d67dfd8c3e554e3'
			}
		};
		request(options, async function(error, response, body) {

			if (error) throw new Error(error);
			const $ = cheerio.load(body)
			resolve({
				judul: $('#header > div > div > div.col-lg-8 > div > table > tbody > tr > td:nth-child(2)').text(),
				download_count: $('#header > div > div > div.col-lg-8 > div > table > tbody > tr > td:nth-child(3)').text(),
				thumb: $('#header > div > div > div.col-lg-8 > div > table > tbody > tr > td:nth-child(1) > img').attr('src'),
				link: $('#dlMP3').attr('onclick').split(`downloadFile('`)[1].split(`',`)[0]
			});
		});
	})
}

async function ssearch (i){let e="https://m.soundcloud.com",t=await axios.get(`${e}/search?q=${encodeURIComponent(i)}`,{headers:{"User-Agent":'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36'}}),a=cheerio.load(t.data),d=[];return a("div > ul > li > div").each((function(i,t){let r=a(t).find("a").attr("aria-label"),v=e+a(t).find("a").attr("href"),s=a(t).find("a > div > div > div > picture > img").attr("src"),n=a(t).find("a > div > div > div").eq(1).text(),o=a(t).find("a > div > div > div > div > div").eq(0).text(),u=a(t).find("a > div > div > div > div > div").eq(1).text(),l=a(t).find("a > div > div > div > div > div").eq(2).text();d.push({title:r,url:v,thumb:s,artist:n,views:o,release:l,timestamp:u})})),{status:t.status,creator:"Caliph",result:d}}



async function GDriveDl(url) {
    let id, res = { "error": true }
    if (!(url && url.match(/drive\.google/i))) return res

    const formatSize = sizeFormatter({
        std: 'JEDEC', decimalPlaces: 2, keepTrailingZeroes: false, render: (literal, symbol) => `${literal} ${symbol}B`
    })

    try {
        id = (url.match(/\/?id=(.+)/i) || url.match(/\/d\/(.*?)\//))[1]
        if (!id) throw 'ID Not Found'
        res = await fetch(`https://drive.google.com/uc?id=${id}&authuser=0&export=download`, {
            method: 'post',
            headers: {
                'accept-encoding': 'gzip, deflate, br',
                'content-length': 0,
                'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',
                'origin': 'https://drive.google.com',
                'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36',
                'x-client-data': 'CKG1yQEIkbbJAQiitskBCMS2yQEIqZ3KAQioo8oBGLeYygE=',
                'x-drive-first-party': 'DriveWebUi',
                'x-json-requested': 'true'
            }
        })
        let { fileName, sizeBytes, downloadUrl } = JSON.parse((await res.text()).slice(4))
        if (!downloadUrl) throw 'Link Download Limit!'
        let data = await fetch(downloadUrl)
        if (data.status !== 200) return data.statusText
        return { downloadUrl, fileName, fileSize: formatSize(sizeBytes), mimetype: data.headers.get('content-type') }
    } catch (e) {
        console.log(e)
        return res
    }
}






var needus =''
if(config.LANG === 'SI') needus = '*‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂∏‡∂ß threads url ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂± !!*'
else needus = "*Please give me threads url !!*" 
var cantf =''
if(config.LANG === 'SI') cantf = '*‡∂∏‡∂ß ‡∂∏‡∑ô‡∂∏ ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù‡∑Ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö!*'
else cantf = "*I cant find this video!*"
var N_FOUND =''
if(config.LANG === 'SI') N_FOUND = "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*"
else N_FOUND = "*I couldn't find anything :(*"
var urlneed =''
if(config.LANG === 'SI') urlneed = "‡∂ë‡∂∫ Baiscopelk ‡∑Ä‡∑ô‡∂≠‡∑í‡∂±‡∑ä ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω ‡∂ã‡∂¥‡∑É‡∑í‡∂ª‡∑ê‡∑É‡∑í ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∂ª‡∂∫‡∑í."
else urlneed = "It downloads sinhala subtitle from Baiscopelk."
var imgmsg =''
if(config.LANG === 'SI') imgmsg = "```‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∑Ä‡∂†‡∂± ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫‡∂ö‡∑ä ‡∂Ω‡∑í‡∂∫‡∂±‡∑ä‡∂±!```"
else imgmsg = "```Please write a few words!```"
var desc =''
if(config.LANG === 'SI') desc = "Tiktok ‡∑Ä‡∑ô‡∂≠‡∑í‡∂±‡∑ä ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∂ª‡∂∫‡∑í."
else desc = "Download videos from Facebook."
var urlneed1 =''
if(config.LANG === 'SI') urlneed1 = "*‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª Tiktok video url ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±*"
else urlneed1 = "*Please give me tiktok video url..*"
var desc1 =''
if(config.LANG === 'SI') desc1 = "Facebook ‡∑Ä‡∑ô‡∂≠‡∑í‡∂±‡∑ä ‡∑Ä‡∑ì‡∂©‡∑í‡∂∫‡∑ù ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∂ª‡∂∫‡∑í."
else desc1 = "Download videos from Facebook."
var urlneed2 =''
if(config.LANG === 'SI') urlneed2 = "*‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª facebook video url ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±*"
else urlneed2 = "*Please give me facebook video url..*"
var desc5 =''
if(config.LANG === 'SI') desc5 = "‡∂ú‡∑ñ‡∂ú‡∂Ω‡∑ä ‡∑Ñ‡∑í ‡∂Ö‡∂Ø‡∑è‡∑Ö ‡∂¥‡∑í‡∂±‡∑ä‡∂≠‡∑ñ‡∂ª ‡∑É‡∑ô‡∑Ä‡∑ì‡∂∏."
else desc5 = "Search for related pics on Google."
var desc2 =''
if(config.LANG === 'SI') desc2 = "unsplash.com ‡∑Ñ‡∑í ‡∂Ö‡∂Ø‡∑è‡∑Ö ‡∂¥‡∑í‡∂±‡∑ä‡∂≠‡∑ñ‡∂ª ‡∑É‡∑ô‡∑Ä‡∑ì‡∂∏."
else desc2 = "Search for related pics on unsplash.com."
var desc3 =''
if(config.LANG === 'SI') desc3 = "pixabay.com ‡∑Ñ‡∑í ‡∂Ö‡∂Ø‡∑è‡∑Ö ‡∂¥‡∑í‡∂±‡∑ä‡∂≠‡∑ñ‡∂ª ‡∑É‡∑ô‡∑Ä‡∑ì‡∂∏."
else desc3 = "Search for related pics on pixabay.com."
var desc4 =''
if(config.LANG === 'SI') desc4 = "bing ‡∑Ñ‡∑í ‡∂Ö‡∂Ø‡∑è‡∑Ö ‡∂¥‡∑í‡∂±‡∑ä‡∂≠‡∑ñ‡∂ª ‡∑É‡∑ô‡∑Ä‡∑ì‡∂∏."
else desc4 = "Searche for related pics on bing."
var errt =''
if(config.LANG === 'SI') errt = "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*"
else errt = "*I couldn't find anything :(*"
var needus =''
if(config.LANG === 'SI') needus = '*‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂∏‡∂ß Instagram url ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂± !!*'
else needus = "*Please give me Instagram url !!*" 
var imgmsg1 =''
if(config.LANG === 'SI') imgmsg1 = '*‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂∏‡∂ß url ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂± !*'
else imgmsg1 = "*Please give me a url !*"
var descg = ''
if(config.LANG === 'SI') descg = "‡∂ë‡∂∫ ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ì ‡∂á‡∂≠‡∑í url ‡∑Ñ‡∑í desktop ‡∂¥‡∑ä‚Äç‡∂ª‡∂∏‡∑è‡∂´‡∂∫‡∑ö ‡∂≠‡∑í‡∂ª ‡∂ª‡∑î‡∑Ä‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ô‡∂∫‡∑í."
else descg = "It gives desktop size screenshot of given url."
var descp = ''
if(config.LANG === 'SI') descp = "‡∂ë‡∂∫ ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ì ‡∂á‡∂≠‡∑í url ‡∑Ñ‡∑í ‡∂Ø‡∑î‡∂ª‡∂ö‡∂Æ‡∂± ‡∂¥‡∑ä‚Äç‡∂ª‡∂∏‡∑è‡∂´‡∂∫‡∑ö ‡∂≠‡∑í‡∂ª ‡∂ª‡∑î‡∑Ä‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ô‡∂∫‡∑í."
else descp = "It gives phone size screenshot of given url."
var desct = ''
if(config.LANG === 'SI') desct = "‡∂ë‡∂∫ ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ì ‡∂á‡∂≠‡∑í url ‡∑Ñ‡∑í ‡∂ß‡∑ê‡∂∂‡∑ä‡∂Ω‡∂ß‡∑ä ‡∂¥‡∑ä‚Äç‡∂ª‡∂∏‡∑è‡∂´‡∂∫‡∑ö ‡∂≠‡∑í‡∂ª ‡∂ª‡∑î‡∑Ä‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ô‡∂∫‡∑í."
else desct = "It gives tablet size screenshot of given url."
var cant = ''
if(config.LANG === 'SI') cant = "*‡∂∏‡∂ß ‡∂≠‡∑í‡∂ª ‡∂ª‡∑î‡∑Ä‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö. ‡∂¥‡∑É‡∑î‡∑Ä ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑è‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.*"
else cant = "*I can't get a screenshot. Try again later.*"
var urlneed3 =''
if(config.LANG === 'SI') urlneed3 = "‡∂ë‡∂∫ androidapksfree ‡∑Ä‡∑ô‡∂≠‡∑í‡∂±‡∑ä mod apps ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∂ª‡∂∫‡∑í."
else urlneed3 = "It downloads mod apps from androidapksfree."
var urlneed4 =''
if(config.LANG === 'SI') urlneed4 = "‡∂ë‡∂∫ playstore ‡∑Ä‡∑ô‡∂≠‡∑í‡∂±‡∑ä apps ‡∂∂‡∑è‡∂ú‡∂≠ ‡∂ö‡∂ª‡∂∫‡∑í."
else urlneed4 = "It downloads apps from playstore."

//============================================================================



cmd({
    pattern: "spotify",
    category: "download",
    react: "üé¨",
    desc: "spotify downloader",
    use: ".spotify lelena",
    filename: __filename   
},
    async (conn, mek, m, { reply, isDev, from, l, q, prefix }) => {
        try {
        
        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
    // Mock API response (Replace this with the actual API endpoint if needed)
    
const links = await fetchJson(`https://apitest1-f7dcf17bd59b.herokuapp.com/search/spotify?q=${q}`)

const search = links.result
    
if (search.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )		
	

var srh = [];  		
	
for (var i = 0; i < search.length; i++) {
srh.push({
title: i + 1,	
description: `${search[i].title}`,
rowId: prefix + 'spotifydl ' + search[i].url
});

	
}		
const sections = [
	{
title: "*Spotify*\n",
rows: srh
}
]

    const listMessage = {
text: `ùôÜùòºùôëùôÑ ùôÄùôìùôÄ SPOTIFY-DL\n`,	    
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})
    




				

cmd({
    pattern: "spotifydl",
    react: "üì•",
    filename: __filename
}, async (conn, mek, m, { from, q, isDev, reply }) => {
	
    if (!q) { 
	return await reply('*Please provide a direct URL!*')}
    try {

const response = await fetchJson(`https://apitest1-f7dcf17bd59b.herokuapp.com/download/spotifydl?url=${q}`)
const details = response.result
  
const cap = `
üéµ *Spotify Track Details* üéµ

üìå *Title*: ${details.title}
üé§ *Artist*: ${details.artis}
‚è±Ô∏è *Durasi*: ${details.durasi}
üîó *Type*: ${details.type}

üîç *Powered by* ${config.FOOTER}
    `;

    


	    
var vajiralod = [
"„Ää ‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã10%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã30%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí„Äã50%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí„Äã80%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äã100%",
"ùô∏ùôΩùô∏ùöÉùô∏ùô∞ùôªùô∏ùöâùô¥ùô≥ ùô≤ùôæùôºùôøùôªùô¥ùöÉùô¥ùô≥ ü¶Ñ..."
]
let { key } = await conn.sendMessage(from, {text: '·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥ç·¥è·¥†…™·¥á...'})

for (let i = 0; i < vajiralod.length; i++) {
await conn.sendMessage(from, {text: vajiralod[i], edit: key })
}



await conn.sendMessage(from, { image: { url: details.image }, caption: cap }, { quoted: mek });

	    
        const message = {
            audio: await getBuffer(details.download),
	        caption: "*·¥†·¥Ä·¥ä…™ Ä·¥Ä-·¥ç·¥Ö  ô è ô·¥õ·¥Ö·¥Ö …¢·¥Ä…¥…¢Íú±*",
            mimetype: "audio/mpeg",
            fileName: `${details.title}\nùôÜùòºùôëùôÑ-ùôÄùôìùôÄ.mp3`,
        };

	    
	const message1 = {
            document: await getBuffer(details.download),
	        caption: "*·¥†·¥Ä·¥ä…™ Ä·¥Ä-·¥ç·¥Ö  ô è ô·¥õ·¥Ö·¥Ö …¢·¥Ä…¥…¢Íú±*",
            mimetype: "audio/mpeg",
            fileName: `${details.title}\nùôÜùòºùôëùôÑ-ùôÄùôìùôÄ.mp3`,
        };    

        await conn.sendMessage(from, message );
await conn.sendMessage(from, message1 );
        
        await conn.sendMessage(from, { react: { text: '‚úÖ', key: mek.key } });
    } catch (error) {
        console.error('Error fetching or sending', error);
      //  await conn.sendMessage(from, '*Error fetching or sending *', { quoted: mek });
    }
});





cmd({
    pattern: "appletone",
    category: "download",
    react: "üé¨",
    desc: "apple ringtone downloader",
    use: ".appletone 2024",
    filename: __filename   
},
    async (conn, mek, m, { reply, isDev, from, l, q, prefix }) => {
        try {
        
        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')

  
const url = `https://www.prokerala.com/downloads/ringtones/search/?q=${q}&mode=search`;
const response = await axios.get(url);  
const $ = cheerio.load(response.data);
   
    const appletone = [];
    $("ul > li.list-item-outer").each((c, d) => {

        appletone.push({
             
         title: $(d).find("div.list-item-body > div > a").text(),
         link: $(d).find("div.list-item-body > div > a").attr("href")

         
        })
    })
 


		
if (appletone.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )		
	

var srh = [];  		
	
for (var i = 0; i < appletone.length; i++) {
srh.push({
title: i + 1,	
description: `${appletone[i].title}`,
rowId: prefix + 'appletonedl ' + appletone[i].link
});

	
}		
const sections = [
	{
title: "*APPLETONE*\n",
rows: srh
}
]

    const listMessage = {
text: `ùôÜùòºùôëùôÑ ùôÄùôìùôÄ APPLETONE-DL\n`,	    
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})



cmd({
    pattern: "appletonedl",
    react: "üì•",
    filename: __filename
}, async (conn, mek, m, { from, q, isDev, reply }) => {
	
    if (!q) {
        return await reply('*Please provide a direct URL!*');
    }
    try {

const url = `https://dl.prokerala.com${q}`
const response = await axios.get(url);  
const $ = cheerio.load(response.data);
   
    const title = $("header > h1").text()
    const dllink = $("#download-options > a").attr("href")
    const duration = $("span.player-total-duration").text()	

    
var vajiralod = [
"„Ää ‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã10%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã30%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí„Äã50%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí„Äã80%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äã100%",
"ùô∏ùôΩùô∏ùöÉùô∏ùô∞ùôªùô∏ùöâùô¥ùô≥ ùô≤ùôæùôºùôøùôªùô¥ùöÉùô¥ùô≥ ü¶Ñ..."
]
let { key } = await conn.sendMessage(from, {text: '·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥ç·¥è·¥†…™·¥á...'})

for (let i = 0; i < vajiralod.length; i++) {
await conn.sendMessage(from, {text: vajiralod[i], edit: key })
}


        const message = {
            audio: await getBuffer(dllink),
	    caption: `Duration: ${duration}\n\n*> ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ã·¥Ä·¥†…™-·¥áx·¥á üêºüíó*`,
            mimetype: "audio/mpeg",
            fileName: `${title}.mp3`,
        };

	const message1 = {
            document: await getBuffer(dllink),
	    caption: `Duration: ${duration}\n\n*> ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ã·¥Ä·¥†…™-·¥áx·¥áüêºüíó*`,
            mimetype: "audio/mpeg",
            fileName: `${title}.mp3`,
        };    

        await conn.sendMessage(from, message );
await conn.sendMessage(from, message1 );
        await conn.sendMessage(from, { react: { text: '‚úÖ', key: mek.key } });
    } catch (error) {
        console.error('Error fetching or sending', error);
        await conn.sendMessage(from, '*Error fetching or sending *', { quoted: mek });
    }
});


cmd({
    pattern: "sounddl",
    filename: __filename   
},
    async (conn, mek, m, { reply, isDev, from, l, q, prefix }) => {
        try {
        
const data = await fetchJson(`https://apitest1-f7dcf17bd59b.herokuapp.com/download/soundcloud?url=${q}`)

const cap = `Title: ${data.result.title}
             Duration: ${data.result.duration}
	     Quality: ${data.result.quality}`

        
const sections = [
{
	title: "",
	rows: [
	    {title: "1", rowId: prefix + `saud ` + data.result.download , description: 'Download Normal Song'},
            {title: "2", rowId: prefix + `sdoc ` + data.result.download , description: 'Download Document Song'},

      ]
    }	  	  
]

    const listMessage = {
caption: cap,
image : { url: data.result.thumbnail },	    
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
		    
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})



cmd({
    pattern: "fetch",
    react: "üì•",
    category:"download",
    filename: __filename
}, async (conn, mek, m, { from, q, isDev, reply }) => {
	
    if (!q) {
        return await reply('*Please provide a direct URL!*');
    }


    try {

const mediaUrl = q.split("|")[0]
        const title = q.split("|")[1]  || 'tc_movie_dl_system'
	    
var vajiralod = [
"„Ää ‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã10%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã30%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí„Äã50%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí„Äã80%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äã100%",
"ùô∏ùôΩùô∏ùöÉùô∏ùô∞ùôªùô∏ùöâùô¥ùô≥ ùô≤ùôæùôºùôøùôªùô¥ùöÉùô¥ùô≥ ü¶Ñ..."
]
let { key } = await conn.sendMessage(from, {text: '·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥ç·¥è·¥†…™·¥á...'})

for (let i = 0; i < vajiralod.length; i++) {
await conn.sendMessage(from, {text: vajiralod[i], edit: key })
}


        const message = {
            document: await getBuffer(mediaUrl),
	        caption: "*> ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ã·¥Ä·¥†…™-·¥áx·¥áüêºüíó*",
            mimetype: "video/mp4",
            fileName: `${title}\nùôÜùòºùôëùôÑ-ùôÄùôìùôÄ.mp4`,
        };

	const message1 = {
            document: await getBuffer(mediaUrl),
	        caption: "*> ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ã·¥Ä·¥†…™-·¥áx·¥áüêºüíó*",
            mimetype: "audio/mpeg",
            fileName: `${title}\nùôÜùòºùôëùôÑ-ùôÄùôìùôÄ.mp3`,
        };    

        await conn.sendMessage(from, message );
await conn.sendMessage(from, message1 );
        await conn.sendMessage(from, { react: { text: '‚úÖ', key: mek.key } });
    } catch (error) {
        console.error('Error fetching or sending', error);
        await conn.sendMessage(from, '*Error fetching or sending *', { quoted: mek });
    }
});










cmd({
    pattern: "save",
    category: "download",
    react: "üéß",
    use: ".save",
    filename: __filename
},

    async (conn, m, mek, { from, q, reply }) => {
        try {
            
//const { repondre , msgRepondu , superUser, auteurMessage } = commandeOptions;

var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});		
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
const baileys_1 = __importStar(require("@whiskeysockets/baileys"));
const decodeJid = (jid) => {
                if (!jid)
                    return jid;
                if (/:\d+@/gi.test(jid)) {
                    let decode = (0, baileys_1.jidDecode)(jid) || {};
                    return decode.user && decode.server && decode.user + '@' + decode.server || jid;
                }
                else
                    return jid;
            };
var origineMessage = mek.key.remoteJid;
const verifGroupe = origineMessage?.endsWith("@g.us");		
var auteurMessage = verifGroupe ? (ms.key.participant ? ms.key.participant : ms.participant) : origineMessage;
 var idBot = decodeJid(conn.user.id);
var servBot = idBot.split('@')[0];
const FranceKing = '94760383959';		
var msgRepondu = mek.message.extendedTextMessage?.contextInfo?.quotedMessage;
var superUser=[servBot,FranceKing].map((s)=>s.replace(/[^0-9]/g)+"@s.whatsapp.net").includes(auteurMessage);
var auteurMessage = verifGroupe ? (mek.key.participant ? mek.key.participant : mek.participant) : origineMessage;

		
  
      if(msgRepondu) {

        console.log(msgRepondu) ;

        let msg ;
  
        if (msgRepondu.imageMessage) {
  
          
  
       let media  = await conn.downloadAndSaveMediaMessage(msgRepondu.imageMessage) ;
       // console.log(msgRepondu) ;
       msg = {
  
         image : { url : media } ,
         caption : msgRepondu.imageMessage.caption,
         
       }
      
  
        } else if (msgRepondu.videoMessage) {
  
          let media  = await conn.downloadAndSaveMediaMessage(msgRepondu.videoMessage) ;
  
          msg = {
  
            video : { url : media } ,
            caption : msgRepondu.videoMessage.caption,
            
          }
  
        } else if (msgRepondu.audioMessage) {
      
          let media  = await conn.downloadAndSaveMediaMessage(msgRepondu.audioMessage) ;
         
          msg = {
     
            audio : { url : media } ,
            mimetype:'audio/mp4',
             }     
          
        } else if (msgRepondu.stickerMessage) {
  
      
          let media  = await conn.downloadAndSaveMediaMessage(msgRepondu.stickerMessage)
  
          let stickerMess = new Sticker(media, {
            pack: 'ùôÜùòºùôëùôÑ-ùôÄùôìùôÄ',
            type: StickerTypes.CROPPED,
            categories: ["ü§©", "üéâ"],
            id: "12345",
            quality: 70,
            background: "transparent",
          });
          const stickerBuffer2 = await stickerMess.toBuffer();
         
          msg = { sticker: stickerBuffer2}
  
  
        }  else {
            msg = {
               q : msgRepondu.conversation,
            }
        }
  
      conn.sendMessage(auteurMessage,msg)
  
      } else { 
	      reply('Mention the message that you want to save') }
  
        } catch (e) {
            console.log(e)
            reply('*Error !!*')
        }
    });




cmd({
    pattern: "pastpaper",	
    react: 'üìë',
    category: "download",
    desc: "pastpaper downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

const url = `https://govdoc.lk/`;
const response = await axios.get(url);  
const $ = cheerio.load(response.data);
   
    const results = [];
    $("#nav > li:nth-child(4) > #submenu-1-4 > li.nav-item").each((c, d) => {

        results.push({
             
         link: $(d).find("a").attr("href"),
         title: $(d).find("a").text().replace(/\n/g,'').replace(/     /g,'')
   
        })
    })
if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
description: results[i].title,
rowId: prefix + 'pp ' + results[i].link
});
}
const sections = [{
title: "_[Result from GovDoc.]_",
rows: srh
}]

    const listMessage = {
caption: `üìÑ ùôÜùòºùôëùôÑ ùôÄùôìùôÄ PASTPAPER-DL üìÑ`,
image : { url: config.LOGO },	    
footer: config.FOOTER,
title: 'Result from GovDoc. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


cmd({
    pattern: "pp",	
    react: 'üìë',
    desc: "pastpaper downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
const response = await axios.get(q);  
const $ = cheerio.load(response.data);
   
    const results = [];
    $("div.row.justify-content-center > div").each((c, d) => {

        results.push({
          
         title: $(d).find("h5.cate-title").text(),
         link: $(d).find("a").attr("href"),
         image: $(d).find("img.img-fluid").attr("src")
         
   
        })
    })
	console.log(results)
if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
description: results[i].title,
rowId: prefix + 'pp1 ' + results[i].link
});
}
const sections = [
{
title: "_[Result from GovDoc.]_",
rows: srh
},
{
	title: "‚Ü™Ô∏è Other Pages",
	rows: [
	    {title: "1.1", rowId: prefix + `pp1 ${q}?page=2` , description: 'Next Page ‚Ü™Ô∏è'},
	]
    } 
]


	
    const listMessage = {
caption: `üìÑ ùôÜùòºùôëùôÑ ùôÄùôìùôÄ PASTPAPER-DL üìÑ`,
image : { url: results[0].image },	    
footer: config.FOOTER,
title: 'Result from GOVDOC. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})



cmd({
    pattern: "pp1",	
    react: 'üìë',
    desc: "pastpaper downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
const response = await axios.get(q);  
const $ = cheerio.load(response.data);
   
    const results = [];
    $("div.row.align-items-end > div").each((c, d) => {

        results.push({
          
         title: $(d).find("div.button.cart-button > button.btn").text(),
       link: $(d).find("a").attr("href"),
         
   
        })
    })


const title1 = $("h1.page-title").text()
const desc = $("div.container > div:nth-child(1) > div > p").text()


if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
description: `${results[i].title} medium`,
rowId: prefix + `ppdl ${results[i].link}|${title1}`
});
}
const sections = [
{
title: "_[Select Medium.]_",
rows: srh
    } 
]
	
    const listMessage = {
text: `ùôÜùòºùôëùôÑ ùôÄùôìùôÄ PASTPAPER-DL


*üìö Title: ${title1}*
 *üìà Desc: ${desc}*

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`,    
footer: config.FOOTER,
title: 'Result from GOVDOC. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})




cmd({
    pattern: "ppdl",
    react: 'üì¶',
    desc: "apk downloader",
    category: "",
    use: '.apk whatsapp',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
var msg = mek
await conn.sendMessage(from, { react: { text: '‚ÑπÔ∏è', key: msg.key }})
if(!q) return await conn.sendMessage(from , { text: '*Need apk link...*' }, { quoted: msg } ) 

const mediaUrl = q.split("|")[0]
        const title = q.split("|")[1]  || 'ùô†ùôñùô´ùôû_ùôöùô≠ùôö_dl_system'



	
const response1 = await axios.get(mediaUrl);  
const $1 = cheerio.load(response1.data);
const link1 = $1("div.col-md-12.d-flex.justify-content-center.mt-md-5.mt-4.mb-4.mx-3 > div > a").attr("href")
const response2 = await axios.get(link1);  
const $2 = cheerio.load(response2.data);
const dllink = $2("#download").attr("href")


var vajiralod = [
"„Ää ‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã10%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã30%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí„Äã50%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí„Äã80%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äã100%",
"ùô∏ùôΩùô∏ùöÉùô∏ùô∞ùôªùô∏ùöâùô¥ùô≥ ùô≤ùôæùôºùôøùôªùô¥ùöÉùô¥ùô≥ ü¶Ñ..."
]
let { key } = await conn.sendMessage(from, {text: '·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥ç·¥è·¥†…™·¥á...'})

for (let i = 0; i < vajiralod.length; i++) {
await conn.sendMessage(from, {text: vajiralod[i], edit: key })
}


        const message = {
            document: await getBuffer(dllink),
	        caption: "*üí´ ùôÜùòºùôëùôÑ ùôÄùôìùôÄ üíô*",
            mimetype: "application/pdf",
            fileName: `${title}.pdf`,
        };

        await conn.sendMessage(from, message );

        await conn.sendMessage(from, { react: { text: '‚úÖ', key: mek.key } });
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})




cmd({
    pattern: "modwhatsapp",	
    react: 'üìë',
    category: "download",
    desc: "modapk downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
	const url = `https://apkdon.net/?s=${q}`;
const response = await axios.get(url);  
const $ = cheerio.load(response.data);
   
    const results = [];
    $("article").each((c, d) => {

        results.push({
             
       link: $(d).find("h2 > a").attr("href"),
         title: $(d).find("h2.entry-title").text()
          

         
        })
    })
if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
description: results[i].title,
rowId: prefix + 'mW ' + results[i].link
});
}
const sections = [{
title: "_[Result from modwhatsapp.]_",
rows: srh
}]

    const listMessage = {
caption: `‚öúÔ∏è ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MODWHATSAPP-DL ‚öúÔ∏è`,
image : { url: config.LOGO },	    
footer: config.FOOTER,
title: 'Result from Mod Whatsapp. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})



cmd({
    pattern: "mw",	
    react: 'üìë',
    desc: "modapk downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
	const response = await axios.get(q);  
const $ = cheerio.load(response.data);

   //const link = $("div.kb-row-layout-wrap.kb-row-layout-id561_470ee8-ae.alignnone.wp-block-kadence-rowlayout > div > div > div > div > a").attr("href")
   const title = $("h1.entry-title").text()
   const version = $("div.kb-row-layout-wrap.kb-row-layout-id561_470ee8-ae.alignnone.wp-block-kadence-rowlayout > div > div > div > div > a > span.kt-btn-inner-text").text()
   const date = $("time.entry-date.published.updated").text()

 const response1 = await axios.get(q);  
 const $1 = cheerio.load(response1.data);
 const results = [];
 $1("div.kt-inside-inner-col > div.wp-block-kadence-advancedbtn.kb-buttons-wrap").each((c, d) => {

     results.push({

 link: $1(d).find("a").attr("href"),
 title1: $1(d).find("span.kt-btn-inner-text").text()
          

         
        })
    })
if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
description: results[i].title1,
rowId: prefix + 'mWdl ' + results[i].link
});
}
const sections = [{
title: "_[Result from modwhatsapp.]_",
rows: srh
}]

    const listMessage = {
text: `‚öúÔ∏è ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MODWHATSAPP-DL ‚öúÔ∏è\n\nüöÄ Title :- ${title}\nüìÑ Date :- ${date}`,    
footer: config.FOOTER,
title: 'Result from Mod Whatsapp. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


cmd({
    pattern: "mwdl",	
    react: 'üìë',
    desc: "modapk downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
	const response2 = await axios.get(q);  
 const $2 = cheerio.load(response2.data);
   
 
 const results = [];
 $2("div.kt-inside-inner-col > div.wp-block-kadence-advancedbtn.kb-buttons-wrap").each((c, d) => {

     results.push({

 dllink: $2(d).find("a").attr("href"),
 dltitle: $2(d).find("span.kt-btn-inner-text").text()
          

         
        })
    })
if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
description: results[i].dltitle,
rowId: prefix + `mdapk ${results[i].dllink}|${results[i].dltitle}`
});
}
const sections = [{
title: "_[Result from modwhatsapp.]_",
rows: srh
}]

    const listMessage = {
text: `‚öúÔ∏è ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MODWHATSAPP-DL ‚öúÔ∏è`,    
footer: config.FOOTER,
title: 'Result from Mod Whatsapp. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


cmd({
    pattern: "modapk",	
    react: 'üìë',
    category: "download",
    desc: "modapk downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
	const url = `https://an1.com/?story=${q}&do=search&subaction=search`;
const response = await axios.get(url);  
const $ = cheerio.load(response.data);
   
    const results = [];
    $("div.item").each((c, d) => {

        results.push({
             
       link: $(d).find("a").attr("href"),
         title: $(d).find("div.name > a > span").text()
          

         
        })
    })
if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
description: results[i].title,
rowId: prefix + 'ma ' + results[i].link
});
}
const sections = [{
title: "_[Result from an1.]_",
rows: srh
}]

    const listMessage = {
caption: `üî± ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MODAPK-DL üî±`,
image : { url: `https://telegra.ph/file/4dbd5c70979a2d6ff7ef9-37c24f77e802ed43d7.jpg` },	    
footer: config.FOOTER,
title: 'Result from an1. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


cmd({
    pattern: "mega",
    category: "download",
    react: "‚¨áÔ∏è",
    use: '.mega < Link >',
    desc: "Download Mega file and send it.",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q || !isUrl(q) || !q.includes('mega.nz')) {
            return reply("Please provide a valid Mega.nz file URL.")
        }

        // Extract file link and key (if present)
        const [fileURL, fileKey] = q.split("#");

        if (!fileKey) {
            return reply("Error: Decryption key is missing in the provided URL.");
        }

        // Use File.fromURL() to create a valid file instance
        const file = File.fromURL(`${fileURL}#${fileKey}`);

        // Track progress
        file.on('progress', (bytesLoaded, bytesTotal) => {
            const percent = (bytesLoaded / bytesTotal * 100).toFixed(2);
            reply(`Downloading: ${percent}% (${(bytesLoaded / 1024 / 1024).toFixed(2)} MB of ${(bytesTotal / 1024 / 1024).toFixed(2)} MB)`);
        });

        const buffer = await file.downloadBuffer();  // Download the file as a buffer

        // Send the file as a document
        await conn.sendMessage(from, { document: buffer, mimetype: "application/octet-stream", fileName: "mega_downloaded_file" }, { quoted: mek });
        reply("File sent successfully!");

    } catch (e) {
        console.error(e);
        reply(`Error: ${e.message}`);
    }
});



cmd({
    pattern: "modgame",	
    react: 'üìë',
    category: "download",
    desc: "modgame downloader",
    filename: __filename
},
async (conn, m, mek, { from, prefix, q, l, isDev, reply }) => {
try{

        if (!q) return await reply('*Please Give Me Text..! üñäÔ∏è*')
	const url = `https://gamekillerapp.com/search/${q}`;
const response = await axios.get(url);  
const $ = cheerio.load(response.data);
   
    const results = [];
    $("div > a.col-12.col-lg-4.col-xl-4.d-flex").each((c, d) => {

        results.push({
          
         title: $(d).find("div.flex-fill.d-flex.flex-column.justify-content-between > h3").text(),
         size: $(d).find("div.download.ellipsis-1 > span").text().trim(),
         type: $(d).find("div.tools.ellipsis-1").text().trim(),
         link: $(d).find("div.flex-fill.d-flex.flex-column.justify-content-between > h3").text().replace(/ /g,'-').replace(/:/g,'-').replace(/--/g,'-'),
         image: $(d).find("div.icon > img").attr("src")
         
 
        })
    })
if (results.length < 1) return await conn.sendMessage(from, { text: "*‡∂∏‡∂ß ‡∂ö‡∑í‡∑É‡∑í‡∑Ä‡∂ö‡∑ä ‡∑É‡∑ú‡∂∫‡∑è‡∂ú‡∂≠ ‡∂±‡∑ú‡∑Ñ‡∑ê‡∂ö‡∑í ‡∑Ä‡∑í‡∂∫ :(*" }, { quoted: mek } )
var srh = [];
for (var i = 0; i < results.length; i++) {
srh.push({
title: i + 1,
 description: results[i].title + ' | ' + results[i].size,
 rowId: prefix + 'mag ' + results[i].link
});
}
const sections = [
	{
title: "_[Result from an1.]_",
rows: srh
}
]

    const listMessage = {
caption: `üí´ ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MOD GAMES-DL üíô

   ‚è≥ Search A Game Name: ${q}
üì≤ Search top 10 Movies\n`,
image : { url: results[0].image },	    
footer: config.FOOTER,
title: 'Result from an1. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})



cmd({
    pattern: "mag",
    react: 'üì¶',
    desc: "apk downloader",
    category: "",
    use: '.apk whatsapp',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
var msg = mek
await conn.sendMessage(from, { react: { text: '‚ÑπÔ∏è', key: msg.key }})
if(!q) return await conn.sendMessage(from , { text: '*Need apk link...*' }, { quoted: msg } ) 


const url = `https://gamekillerapp.com/games/${q}`;
const response = await axios.get(url);  
const $ = cheerio.load(response.data);     
const title =  $("div.d-flex.flex-column.justify-content-between.flex-fill > h1").text()
const image = $("div.icon > img").attr("src")
const link = $("a.ordinary-download.d-flex.justify-content-center.align-items-center").attr("href")
const link1 = `https://gamekillerapp.com${link}`
const date = $("div.updateTime").text()
const category = $("div:nth-child(6) > div.col-6.desc-text > a").text().trim()
const version = $("div:nth-child(3) > div.col-6.desc-text").text().trim()
const modinfo = $("div:nth-child(4) > div.col-6.desc-text > a:nth-child(3)").text().trim()
const response1 = await axios.get(link1);  
const $1 = cheerio.load(response1.data);
const dl = $1("section.normal-download > a").attr("href")


let listdata = `[üë®‚Äçüíª ùôÜ ùòº ùôë ùôÑ  ùôÄùôìùôÄ üë®‚Äçüíª]
   
 *MOD GAMES-DOWNLOADER*

 *üìö Title: ${title}*
 *üìà Date: ${date}*
 *‚ôì Category: ${category}*
 *üß¨ Vertion: ${version}*
 *üåê Mod Info: ${modinfo}*
 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`
 const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + `mdapk ${dl}|${title}` , description: 'Download the modgames'},
	]
    } 
]      
  const listMessage = {
caption: listdata,
image : { url: image },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


cmd({
    pattern: "ma",
    react: 'üì¶',
    desc: "apk downloader",
    category: "",
    use: '.apk whatsapp',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
var msg = mek
await conn.sendMessage(from, { react: { text: '‚ÑπÔ∏è', key: msg.key }})
if(!q) return await conn.sendMessage(from , { text: '*Need apk link...*' }, { quoted: msg } ) 


const response = await axios.get(q);  
const $ = cheerio.load(response.data);
   

const link = $("a.btn.btn-lg.btn-green").attr("href")
const image = $("figure.img > img").attr("src")
const title = $("h1.title.xxlgf").text()
const os = $("div.app_view-first > div > ul > li:nth-child(1) > span").text()
const version = $("div.app_view-first > div > ul > li:nth-child(2) > span").text()
const size = $("div.app_view-first > div > ul > li:nth-child(3) > span").text()
const li = 'https://an1.com/'
const response1 = await axios.get(`${li}${link}`);  
const $1 = cheerio.load(response1.data);
const link1 = $1("#pre_download").attr("href")


let listdata = `[üë®‚Äçüíª ùôÜ ùòº ùôë ùôÑ  ùôÄùôìùôÄ üë®‚Äçüíª]
   
 *MOD APK-DOWNLOADER*

 *üìö ·¥Ä·¥ò·¥ò …¥·¥Ä·¥ç·¥á: ${title}*
 *üìà ·¥Ä·¥ò·¥ò Íú±…™·¥¢·¥á: ${size}*
 *üß¨ ·¥Ä·¥ò·¥ò ·¥†·¥á ÄÍú±…™·¥è…¥: ${version}*
 *üåê ·¥Ä·¥ò·¥ò ·¥èÍú±: ${os}*
 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`
 const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + `mdapk ${link1}|${title}` , description: 'Download the modapk'},
	]
    } 
]      
  const listMessage = {
caption: listdata,
image : { url: image },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})



cmd({
    pattern: `mdapk`,
    react: "üì•",
    dontAddCommandList: true,
    filename: __filename
}, async (conn, mek, m, { from, q, isDev, reply }) => {
	
    if (!q) {
        return await reply('*Please provide a direct URL!*');
    }


    try {


        //const mediaUrl = q.trim();
        const mediaUrl = q.split("|")[0]
        const title = q.split("|")[1]  || 'tc_movie_dl_system'
        


var vajiralod = [
"„Ää ‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã10%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí„Äã30%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñí‚ñí„Äã50%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí„Äã80%",
"„Ää ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà„Äã100%",
"ùô∏ùôΩùô∏ùöÉùô∏ùô∞ùôªùô∏ùöâùô¥ùô≥ ùô≤ùôæùôºùôøùôªùô¥ùöÉùô¥ùô≥ ü¶Ñ..."
]
let { key } = await conn.sendMessage(from, {text: '·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢ ·¥Ä·¥ò·¥ã...'})

for (let i = 0; i < vajiralod.length; i++) {
await conn.sendMessage(from, {text: vajiralod[i], edit: key })
}



        const message = {
            document: await getBuffer(mediaUrl),
	    caption: "*ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MOD APk*",
            mimetype: "application/mod.apk",
            fileName: `${title}.apk`,
        };


	    
        await conn.sendMessage(from, message );

        await conn.sendMessage(from, { react: { text: '‚úÖ', key: mek.key } });
    } catch (error) {
        console.error('Error fetching or sending', error);
        await conn.sendMessage(from, '*Error fetching or sending *', { quoted: mek });
    }
});








cmd({
    pattern: "xnxx",
    react: "üì±",
    desc: "xxx video dowloader",
    category: "download",
    use: '.xnxx mia kalifa',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return mek.reply(`Enter Query`)
	const fg = require('api-dylux')
	let res = await fg.xnxxSearch(q)
           let ff = res.result.map(() => `‡∂∏‡∑ú‡∂±‡∑è‡∂Ø ‡∑Ñ‡∑î‡∂≠‡∑ä‡∂≠‡∑ú ‡∂ö‡∑î‡∂±‡∑î‡∑Ñ‡∂ª‡∂¥ ‡∂â‡∂Ω‡∑ä‡∂Ω‡∂±‡∑ä‡∂±‡∑ôü§£ \n ‡∂∂‡∑ê‡∂±‡∑ä‡∂©‡∑ä ‡∂ö‡∂ª‡∂ú‡∂±‡∑í‡∂∏‡∑ä ‡∂î‡∑Ä ‡∂â‡∂Ω‡∑ä‡∂Ω‡∂Ω ‡∂ã‡∂∂‡∑ô whatsapp ‡∂ë‡∂öü§£\n‡∑Ä‡∂Ω‡∂≠‡∑ä‡∂≠‡∂∫‡∑è `)
	//return reply('‡∂∏‡∑ú‡∂±‡∑è‡∂Ø ‡∑Ñ‡∑î‡∂≠‡∑ä‡∂≠‡∑ú ‡∂ö‡∑î‡∂±‡∑î‡∑Ñ‡∂ª‡∂¥ ‡∂â‡∂Ω‡∑ä‡∂Ω‡∂±‡∑ä‡∂±‡∑ôü§£ \n ‡∂∂‡∑ê‡∂±‡∑ä‡∂©‡∑ä ‡∂ö‡∂ª‡∂ú‡∂±‡∑í‡∂∏‡∑ä ‡∂î‡∑Ä ‡∂â‡∂Ω‡∑ä‡∂Ω‡∂Ω ‡∂ã‡∂∂‡∑ô whatsapp ‡∂ë‡∂öü§£\n‡∑Ä‡∂Ω‡∂≠‡∑ä‡∂≠‡∂∫‡∑è')
              if (res.status) mek.reply(ff)

const data = res.result
if (data.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < data.length; i++) {
srh.push({
title: i + 1,
description: data[i].title,
rowId: prefix + 'xnxxdl ' + data[i].link + '+' + data[i].title
});
}
const sections = [{
title: "_[Result from androidapksfree.]_",
rows: srh
}]
const listMessage = {
text: `[üí´ ùôÜ ùòº ùôë ùôÑ  ùôÄùôìùôÄ üíô]

   *XNXX VIDEO DOWNLOADER*

*üì± Enterd Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from androidapksfree. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


cmd({
    pattern: "img",
    react: 'üñºÔ∏è',
    desc: "image downloader",
    category: "download",
    use: '.img car',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let dat = `[üë®‚Äçüíª ùôÜ ùòº ùôë ùôÑ  ùôÄùôìùôÄ üë®‚Äçüíª]
   
 ‚ñè *IMG-DOWNLOADER*

 ‚ñè *üé≠  Ä·¥á«´·¥ú·¥áÍú±·¥õ·¥á Ä: ${pushname}*
 ‚ñè *‚úèÔ∏è  Ä·¥áÍú±·¥ú ü·¥õ: ${q}*

‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óâ`
  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'imgno ' + q , description: 'Normal type images üìÅ'},
	    {title: "2", rowId: prefix + 'imgdoc ' + q , description: 'Document type images üñºÔ∏è'} ,
            

	]
    } 
]   
  const listMessage = {
caption: dat,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


	
cmd({
    pattern: "imgno",
    react: 'üëæ',
    desc: 'to down images',
    category: "",
    use: '.im',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    
    if (!q) throw `Example: ${prefix + command} Bike`

    let gis = require('g-i-s')
    gis(q, async (error, result) => {
        if (error) {
            console.error('Error fetching images:', error);
		
            return reply('Error fetching images. Please try again later.')
        }

        const topImages = result.slice(0, 5); // Extract top 5 images

        for (let i = 0; i < topImages.length; i++) {
            const imageUrl = topImages[i].url
          let Message = {
              image: { url: imageUrl },caption: `*-------„Äå ùôÜùòºùôëùôÑ ùôÄùôìùôÄ GIMAGE SEARCH „Äç-------*\nü§† *Query* : ${q}\n\nüîó *Image ${i + 1} Url* : ${imageUrl}`,
           }

//let senda = await conn.sendMessage(from, { document: {url: imageUrl },fileName: 'image' + '.jpg', mimetype: 'image/jpeg' ,caption: `*-------„Äå ùôÜùòºùôëùôÑ ùôÄùôìùôÄ GIMAGE SEARCH „Äç-------*\nü§† *Query* : ${q}\n\nüîó *Image ${i + 1} Url* : ${imageUrl}`,}, { quoted: mek })  
		
            conn.sendMessage(from, Message, { quoted: mek })
        }
    })
} catch (e) {
l(e)
}
})




cmd({
    pattern: "imgdoc",
    react: 'üëæ',
    desc: 'to down images',
    category: "",
    use: '.im',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    
    if (!q) throw `Example: ${prefix + command} Bike`

    let gis = require('g-i-s')
    gis(q, async (error, result) => {
        if (error) {
            console.error('Error fetching images:', error);
		
            return reply('Error fetching images. Please try again later.')
        }

        const topImages = result.slice(0, 5); // Extract top 5 images

        for (let i = 0; i < topImages.length; i++) {
            const imageUrl = topImages[i].url
          let Message = {
              document: { url: imageUrl },fileName: 'image' + '.jpg', mimetype: 'image/jpeg' ,caption: `*-------„Äå ùôÜùòºùôëùôÑ ùôÄùôìùôÄ GIMAGE SEARCH „Äç-------*\nü§† *Query* : ${q}\n\nüîó *Image ${i + 1} Url* : ${imageUrl}`,
           }

//let senda = await conn.sendMessage(from, { document: {url: imageUrl },fileName: 'image' + '.jpg', mimetype: 'image/jpeg' ,caption: `*-------„Äå VAJIRA MD GIMAGE SEARCH „Äç-------*\nü§† *Query* : ${q}\n\nüîó *Image ${i + 1} Url* : ${imageUrl}`,}, { quoted: mek })  
		
            conn.sendMessage(from, Message, { quoted: mek })
        }
    })
} catch (e) {
l(e)
}
})




cmd({
    pattern: "psong",
    react: 'üëæ',
    desc: 'to down songs',
    category: "download",
    use: '.song2',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  if (!q) {
    return reply('Enter YouTube Video Link or Search Query!');
  }


  
    const results = await yts(q);

    if (results.videos.length > 0) {
      let pollOptions = [];

      const uniqueKey = `yts_${optionIndex}`;
      const urlObject = {};

      for (let i = 0; i < Math.min(5, results.videos.length); i++) {
        const result = results.videos[i];
        const videoUrl = result.url;
        const title = result.title;

        urlObject[`${optionIndex}.${i + 1}`] = videoUrl;
        pollOptions.push(`.tet ${optionIndex}.${i + 1} ${title}`);
		    }

      if (!videoSearchResults.has(uniqueKey)) {
        videoSearchResults.set(uniqueKey, {});
      }

      videoSearchResults.set(uniqueKey, Object.assign(videoSearchResults.get(uniqueKey), urlObject));

      await conn.sendPoll(from, 'Choose a video to download:', [...pollOptions]);


      optionIndex += 1;
    } else {
      return reply('No search results found.');
    }

} catch (e) {
console.error('Error during play:', e);
    mek.reply('Unexpected error occurred.');	
l(e)
}
})      

cmd({
    pattern: "tet",
    react: 'üëæ',
    desc: 'to take song',
    category: "download",
    use: '.tet',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  if (!q) {
    return reply('Please specify the video you want to play. Use the format: play [unique-key]');
    
  }

  const match = q.match(/(\d+)\.(\d+)/);

  if (!match) {
    return reply('Invalid format. Please provide a valid unique key (e.g., 1.1)');
  
  }

  const optionIndex = parseInt(match[1]);
  const subOption = parseInt(match[2]);

  const uniqueKey = `yts_${optionIndex}`;

  if (videoSearchResults.has(uniqueKey)) {
    const selectedUrl = videoSearchResults.get(uniqueKey)[`${optionIndex}.${subOption}`];

    if (selectedUrl) {
      
        const videoInfo = await ytdl.getInfo(selectedUrl);

        const title = videoInfo.title || (videoInfo.videoDetails && videoInfo.videoDetails.title) || 'N/A';
const uploadDate = formatUploadDate(videoInfo.videoDetails.uploadDate) || 'N/A'; 
        // Construct caption with audio details
        const pollMessage = `
‚ï≠‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚Ä¢‚àû‚Ä¢‚ïê‚ïê‚ïÆ
‚îÇ‚øª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*
‚îÇ  *Youtube Mp4 Player* ‚ú®
‚îÇ‚øª *Title:* ${title}
‚îÇ‚øª *Author:* ${videoInfo.videoDetails.author.name || 'N/A'}
‚îÇ‚øª *Duration:* ${videoInfo.videoDetails.lengthSeconds}s
‚îÇ‚øª *Views:* ${videoInfo.videoDetails.viewCount.toLocaleString() || 'N/A'}
‚îÇ‚øª *Upload Date:* ${uploadDate}
‚ï∞‚ïê‚ïê‚Ä¢‚àû‚Ä¢‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïØ
`;

        await conn.sendPoll(from, pollMessage, [
          `.ùêÄùêÆùêùùê¢ùê® ${optionIndex}.${subOption}`,
          `.ùêïùê¢ùêùùêûùê® ${optionIndex}.${subOption}`,
          `.ùêÄùêÆùêùùê¢ùê®ùêùùê®ùêúùêÆùê¶ùêûùêßùê≠ ${optionIndex}.${subOption}`,
          `.ùêïùê¢ùêùùêûùê®ùêùùê®ùêúùêÆùê¶ùêûùêßùê≠ ${optionIndex}.${subOption}`
        ]);
        
      
      } else {
      return reply('Invalid sub-option. Please choose a valid sub-option.');
    }
  } else {
    return reply('Invalid unique key. Please provide a valid unique key.');
  }
      } catch (e) {
        console.error('Error during poll creation:', e);
        return reply('Unexpected error occurred during poll creation.')
l(e)
}
})      


	
cmd({
    pattern: "xnxxdl",
    react: 'üëæ',
    desc: 'to take xnxx video',
    category: "download",
    use: '.xnxxdl',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
        if (!q.includes('xnxx.com')) return mek.reply(`Enter an xnxx link`)
        const fg = require('api-dylux')
            let xn = await fg.xnxxdl(q)
conn.sendMessage(mek.chat, { caption: `  *XNXX DL*
        
‚úç *Title:* ${xn.title}
‚åõ *Duration:* ${xn.duration}
üìΩ *Visual Quality:* ${xn.quality}`, video: {url: xn.url_dl} }, { quoted: mek })
} catch (e) {
l(e)
}
})   


	
cmd({
    pattern: "tempmail",
    react: 'üëæ',
    desc: 'to take a tempmail',
    category: "download",
    use: '.tempmail',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
const link = "https://dropmail.me/api/graphql/web-test-wgq6m5i?query=mutation%20%7BintroduceSession%20%7Bid%2C%20expiresAt%2C%20addresses%20%7Baddress%7D%7D%7D"


        let response = await fetch(link);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        let data = await response.json();
        let email = data["data"]["introduceSession"]["addresses"][0]["address"];
        let id_ = data["data"]["introduceSession"]["id"];
        let time = data["data"]["introduceSession"]["expiresAt"];
//reply(email)
let info = `ùòåùòîùòàùòêùòì = ${email}
ùòêùòã = ${id_}
ùòõùòêùòîùòå = ${time}`	


let msg = generateWAMessageFromContent(
      m.chat,
      {
        viewOnceMessage: {
          message: {
            interactiveMessage: {
              body: {
                text: `${info}` },
              carouselMessage: {
                cards: [
                  {
                    
                    header: proto.Message.InteractiveMessage.Header.create({
          ...(await prepareWAMessageMedia({ image: { url: config.LOGO } }, { upload: conn.waUploadToServer })),
          title: ``,
          gifPlayback: true,
          subtitle: "ùôÜùòºùôëùôÑ ùôÄùôìùôÄ",
          hasMediaAttachment: false
        }),
                    body: { text: ``},
                    nativeFlowMessage: {
                      buttons: [
                        {
                 "name": "cta_copy",
                 "buttonParamsJson": `{\"display_text\":\"ùòäùòñùòóùò† ùòõùòåùòîùòóùòîùòàùòêùòì\",\"id\":\"123456789\",\"copy_code\":\"${email}\"}`
              },
                      ],
                    },
                  },
                  {                   

header: proto.Message.InteractiveMessage.Header.create({
          ...(await prepareWAMessageMedia({ image: { url: config.LOGO } }, { upload: conn.waUploadToServer })),
          title: ``,
          gifPlayback: true,
          subtitle: "ùôÜùòºùôëùôÑ ùôÄùôìùôÄ",
          hasMediaAttachment: false
        }),
                    body: { text: ``},
                    nativeFlowMessage: {
                      buttons: [
                        {
                 "name": "cta_copy",
                 "buttonParamsJson": `{\"display_text\":\"ùòäùòñùòóùò† ùòêùòã\",\"id\":\"123456789\",\"copy_code\":\"${id_}\"}`
              },
                      ],
                    },
                  },                                    
                ],
                            messageVersion: 1,
                        },
                         contextInfo: {
                         mentionedJid: [m.sender],
                         forwardingScore: 999,
                         isForwarded: true,
                         forwardedNewsletterMessageInfo: {
                         newsletterJid: '120363366147331561@newsletter',
                         newsletterName: `‚õÖ ùôÜùòºùôëùôÑ ùôÄùôìùôÄ üíô`,
                         serverMessageId: 143
                            }
                        }
                    }
                }
            },
        },
        { quoted: m })
        
            await conn.relayMessage(msg.key.remoteJid, msg.message, {
      messageId: msg.key.id,
    });


} catch (e) {
reply()
l(e)
}
})   




cmd({
    pattern: "checkmail",
    react: 'üëæ',
    desc: 'to see mail',
    category: "download",
    use: '.checkmail',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
        if (!q) {
            
            return reply(`*Provide me tempmail for view inbox*`);
        }

        const link = `https://dropmail.me/api/graphql/web-test-wgq6m5i?query=query%20(%24id%3A%20ID!)%20%7Bsession(id%3A%24id)%20%7B%20addresses%20%7Baddress%7D%2C%20mails%7BrawSize%2C%20fromAddr%2C%20toAddr%2C%20downloadUrl%2C%20text%2C%20headerSubject%7D%7D%20%7D&variables=%7B%22id%22%3A%22${q}%22%7D`;
        let response = await fetch(link);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        let data = await response.json();
        let inbox = data["data"]["session"]["mails"];

        // return the size of the inbox to verify the amount of mail and whether the mail has arrived
        return [inbox, inbox.length];
       
        } catch (e) {
            console.error('Error during API request:', e)
            
            reply()      
l(e)
}
})   

		    

cmd({
    pattern: "gitclone",
    react: "üîñ",
    desc: "download github repos",
    category: "download",
    use: '.gitclone',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
                                                                   
                                  
  let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
                              if (!args[0]) reply(`Use ${prefix}gitclone repo link\n: https://github.com/VajiraTech/QUEEN-IZUMI-MD`)
                              if (!regex1.test(args[0])) return reply('link')
                              let [, user, repo] = args[0].match(regex1) || []
                              repo = repo.replace(/.git$/, '')
                              let url = `https://api.github.com/repos/${user}/${repo}/zipball`
                              let filename =  `${user}${repo}`
                              //(await fetch(url, {method: 'HEAD'})).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
                              conn.sendMessage(mek.chat, { document: { url: url }, fileName: filename+'.zip', mimetype: 'application/zip',caption: '*·¥ã·¥Ä·¥†…™‚Ä¢·¥áx·¥á*\n*·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ã·¥Ä·¥†…™ ·¥áx·¥á üêãüíó*' }, { quoted: mek }).catch((err) => reply(mess.error))                             
} catch (e) {
reply()
l(e)
}
})
	

//============================Ehi command===============================


cmd({
    pattern: "ehi",
    react: 'üñºÔ∏è',
    desc: "ehi files downloader",
    category: "download",
    use: '.ehi',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let dat = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ù® ‚ùÑ ‚ù©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó

            *üéóÔ∏è ·¥ã·¥Ä·¥†…™ ·¥áx·¥á ·¥†3 ·¥á ú…™ üéóÔ∏è*
    
 ‚ñ´ “ì Ä·¥á·¥á ·¥á ú…™
 ‚ñ´ ·¥ç·¥Ä·¥ã·¥á ·¥Ö·¥Ä·¥õ·¥á
 ‚ñ´ ·¥áx·¥ò…™ Ä·¥á ·¥Ö·¥Ä·¥õ·¥á 
     
 _‚úï …¥·¥è  ú·¥Ä·¥Ñ·¥ã…™…¥…¢_
 _‚úï …¥·¥è s·¥ò·¥Ä·¥ç_ 
 _‚úï …¥·¥è ·¥Ö·¥Ö·¥ès_
 _‚úï ·¥Ö·¥è…¥\'·¥õ ·¥ús·¥á ·¥ú…¥…¥·¥á·¥Ñ·¥áss·¥Ä Ä è ·¥°·¥è Ä·¥ã_
 
    *·¥á…¥·¥ä·¥è è  è·¥è·¥ú Ä ·¥á ú…™ “ì…™ ü·¥ás üíû.*

‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[üíÄ]`

   const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'httpinjector ' + q , description: 'apk of http injector'},
	    {title: "2", rowId: prefix + 'ehifiles ' + q , description: 'Down ehi files'} ,
            {title: "3", rowId: prefix + 'aboutehi ' + q , description: 'Info of ehi files'} 

	]
    } 
] 
  const listMessage = {
caption: dat,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})





cmd({
    pattern: "aboutehi",
    category: "",
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{                    
   let dat =  `üí¨ Ehi file ‡∂∫‡∂±‡∑î* ,
‡∂î‡∂∂‡∂ß whatsapp package ‡∂∂‡∑è‡∑Ä‡∑í‡∂≠‡∑è‡∂ö‡∂ª free internet ‡∂Ω‡∂∂‡∑è‡∂ú‡∂≠ ‡∑Ñ‡∑ê‡∂ö‡∑í ‡∂ö‡∑ä‚Äç‡∂ª‡∂∏‡∂∫‡∂ö‡∑í.

‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫‡∂ö‡∑ä ‡∂Ω‡∑ô‡∑É , ‡∂î‡∂∂‡∂ß whatsapp package ‡∂ë‡∂ö ‡∂∂‡∑è‡∑Ä‡∑í‡∂≠‡∑è‡∂ö‡∂ª‡∂∏‡∑í‡∂±‡∑ä tiktok , fb , youtube , google ‡∂∫‡∑è‡∂∏ ‡∑Ä‡∑ê‡∂±‡∑í‡∂Ø‡∑ö ‡∑É‡∑í‡∂Ø‡∑î‡∂ö‡∂ª ‡∑Ñ‡∑ê‡∂ö‡∑í‡∑Ä‡∑ì‡∂∏.
‡∂∏‡∑ô‡∂∏ ehi file ‡∂ã‡∂¥‡∂ª‡∑í‡∂∏ ‡∂Ö‡∂±‡∑ä‡∂≠‡∂ª‡∑ä‡∂¢‡∑è‡∂Ω ‡∑Ä‡∑ö‡∂ú‡∂∫‡∂ö‡∑ä ‡∂Ω‡∂∂‡∑è ‡∂±‡∑ú‡∂Ø‡∑ô‡∂∫‡∑í. ‡∂±‡∂∏‡∑î‡∂≠‡∑ä ‡∂î‡∂∂‡∂ß ‡∂∫‡∂∏‡∑ä ‡∑Ä‡∑ö‡∂ú‡∂∫‡∂ö‡∑í‡∂±‡∑ä ‡∂Ö‡∂±‡∑ä‡∂≠‡∂ª‡∑ä‡∂¢‡∑è‡∂Ω ‡∂¥‡∑Ñ‡∑É‡∑î‡∂ö‡∂∏‡∑ä ‡∂Ω‡∂∂‡∑è‡∂ú‡∂≠ ‡∑Ñ‡∑ê‡∂ö.
‡∂î‡∂∂‡∂ß ‡∂∏‡∑ô‡∂∏ ehi file ‡∑É‡∑è‡∂∏‡∑è‡∂±‡∑ä‚Äç‡∂∫‡∂∫‡∑ô‡∂±‡∑ä ‡∂Ö‡∂¥ ‡∂∂‡∑è‡∑Ä‡∑í‡∂≠‡∑è‡∂ö‡∂ª‡∂± 
whatsapp , facebook , youtube , zoom ‡∂∫‡∂± ‡∂Ü‡∂Ø‡∑ì package ‡∑Ä‡∂Ω‡∂ß ‡∂ú‡∑ê‡∂Ω‡∂¥‡∑ô‡∂± ‡∂Ü‡∂ö‡∑è‡∂ª‡∂∫‡∑ö file ‡∂∂‡∑è‡∑Ä‡∑í‡∂≠‡∑è‡∂ö‡∂ª ‡∑Ñ‡∑ê‡∂ö 


‡∂∂‡∑è‡∑Ä‡∑í‡∂≠‡∑è‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∑ö ‡∂ö‡∑ô‡∑É‡∑ö‡∂Ø ?
1. http injector app ‡∂ë‡∂ö ‡∂î‡∂∂‡∂ú‡∑ö phone ‡∂ë‡∂ö‡∂ß install ‡∂ö‡∂ª‡∂ú‡∂±‡∑ä‡∂± 
2. ‡∂î‡∂∂‡∂ú‡∑ö package ‡∂ë‡∂ö‡∂ß ‡∂Ö‡∂Ø‡∑è‡∂Ω ehi file ‡∂ë‡∂ö ‡∂≠‡∑ù‡∂ª‡∑è‡∂ú‡∂±‡∑ä‡∂± 
3. ‡∂ë‡∂∏ file ‡∂ë‡∂ö httpinjector app ‡∂ë‡∂ö‡∂ß ‡∂á‡∂≠‡∑î‡∂Ω‡∂≠‡∑ä ‡∂ö‡∂ª start ‡∂∂‡∂ß‡∂±‡∑ä ‡∂ë‡∂ö ‡∂î‡∂∂‡∂±‡∑ä‡∂± 
( ‡∂î‡∂∂‡∂ß ‡∂∏‡∑ô‡∂∏ file ‡∂∂‡∑è‡∑Ä‡∑í‡∂≠‡∑è‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß‡∂±‡∂∏‡∑ä ‡∂â‡∑Ñ‡∂≠ ‡∂ö‡∑í‡∑É‡∑í‡∂∫‡∂∏‡∑ä ‡∑Ñ‡∑ù package 1‡∂ö‡∑ä ‡∂Ø‡∂∏‡∑è‡∂ú‡∑ô‡∂± ‡∂≠‡∑í‡∂∂‡∑í‡∂∫ ‡∂∫‡∑î‡∂≠‡∑î‡∂∫ )

*¬© ·¥õ·¥á·¥Ñ ú…¥…™·¥Ñ·¥Ä ü ·¥Ñ è ô·¥á ÄÍú±*

============================================================================

*üí¨ Ehi file is*,
 It is a method where you can get free internet by using whatsapp package.
 For example, you can use whatsapp package to go to tiktok, fb, youtube, google etc.

 This ehi file does not provide maximum internet speed.  But you can get internet facility at some speed.
 You can find this ehi file which we usually use
 You can use the type of file suitable for packages like whatsapp, facebook, youtube, zoom etc

*How to use*
 1. Install the http injector app on your phone.
 2. Select the ehi file related to your package.
 3. Enter that file into the httpinjector app and press the start button.
_( If you want to use this file, you must have one of the above packages installed )_


*¬© ·¥õ·¥á·¥Ñ ú…¥…™·¥Ñ·¥Ä ü ·¥Ñ è ô·¥á ÄÍú±*`
                  
                  const buttons = []
  const buttonMessage = {
      caption: dat,
      footer: `*·¥ã·¥Ä·¥†…™ ·¥áx·¥á‚Ä¢·¥ç·¥ú ü·¥õ…™-·¥Ö·¥á·¥†…™·¥Ñ·¥á*\n*·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ã·¥Ä·¥†…™  ô·¥è è*`,
      buttons: buttons,
      headerType: 1
  }
return await conn.buttonMessage(from, buttonMessage, mek)
} catch (e) {
l(e)
}
})




  cmd({
  pattern: "httpinjector",
  dontAddCommandList: true,
  filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
await conn.sendMessage(from, { react: { text: 'üì•', key: mek.key }})
await conn.sendMessage(from, { document: { url: 'https://github.com/VajiraTech/Izumi-ehi/blob/main/Http_injector/HTTP%20Injector%20(SSHProxyV2Ray)%20VPN.apk' },mimetype: 'application/vnd.android.package-archive', fileName: `HTTP Injector Q·¥ú·¥á·¥á…¥-…™·¥¢·¥ú·¥ç…™ (SSHProxyV2Ray) VPN.apk`,  caption: config.FOOTER}, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
} catch (e) {
  reply('*ERROR !!*')
l(e)
}
})

//=================================APK COMMANDS=====================================


cmd({
    pattern: "fmmods",
    alias: ["wamod","wamods","fmmod"],
    react: 'üì≤',
    desc: "Download all fmmods.",
    category: "download",
    use: '.fmmods',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted,prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  let response = (await fetchJson('https://api.maher-zubair.tech/whatsapp/wamods')).data
  const sections = [
      {
	title: "",
	rows: [
    {title: "1", rowId: prefix + 'dmod ' + response.com_whatsapp.link + '+' + response.com_whatsapp.name, description: response.com_whatsapp.name },
    {title: "2", rowId: prefix + 'dmod ' + response.com_fmwhatsapp.link + '+' + response.com_fmwhatsapp.name, description: response.com_fmwhatsapp.name },
    {title: "3", rowId: prefix + 'dmod ' + response.com_gbwhatsapp.link + '+' + response.com_gbwhatsapp.name, description: response.com_gbwhatsapp.name }, 
    {title: "4", rowId: prefix + 'dmod ' + response.com_yowhatsapp.link + '+' + response.com_yowhatsapp.name, description: response.com_yowhatsapp.name },
  ]
    } 
]

  const listMessage = {
caption : `[üë®‚Äçüíª ùôÜ ùòº ùôë ùôÑ  ùôÄùôìùôÄ üë®‚Äçüíª]
      
*Foud Whatsapp Mod Downloader üì≤*
`,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})
	
cmd({
  pattern: "dmod",
  dontAddCommandList: true,
  filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
await conn.sendMessage(from, { react: { text: 'üì•', key: mek.key }})
let [modlink, modname] = q.split `+`;
await conn.sendMessage(from, { document: { url: modlink }, fileName:  modname + '.apk' , mimetype: 'application/vnd.android.package-archive'}, {quoted: mek})
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
} catch (e) {
  reply('*ERROR !!*')
l(e)
}
})




cmd({
    pattern: "apk",
    react: 'üì¶',
    desc: "apk downloader",
    category: "download",
    use: '.apk whatsapp',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
var msg = mek
await conn.sendMessage(from, { react: { text: '‚ÑπÔ∏è', key: msg.key }})
if(!q) return await conn.sendMessage(from , { text: '*Need apk link...*' }, { quoted: msg } ) 
const data = await apkdl.download(q)
let listdata = `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]
   
 *APK-DOWNLOADER*

 *üìö ·¥Ä·¥ò·¥ò …¥·¥Ä·¥ç·¥á: ${data.name}*
 *üìà ·¥Ä·¥ò·¥ò Íú±…™·¥¢·¥á: ${data.size}*
 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`
 const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'dapk ' + q , description: 'Download the apk'},
	    {title: "2", rowId: prefix + 'apk1 ' + q , description: 'Download many apk'} ,
	    {title: "3", rowId: prefix + 'apkinfo ' + q , description: 'Info of apk'}, 

	]
    } 
]      
  const listMessage = {
caption: listdata,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})

cmd({
    pattern: "apk1",
    react: "üì±",
    alias: ["findapk","playstore"],
    desc: urlneed4,
    category: "download",
    use: '.apk whatsapp',
    filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await conn.sendMessage(from , { text: imgmsg }, { quoted: mek } )        
const data2 = await apkdl.search(q)
const data = data2
if (data.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
for (var i = 0; i < data.length; i++) {
srh.push({
description: data[i].name,
title: i + 1,
rowId: prefix + 'dapk ' + data[i].id
});
}
const sections = [{
title: "_[Result from playstore.]_",
rows: srh
}]
const listMessage = {
text: `‚îå‚îÄ‚îÄ‚îÄ[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *APK DOWNLOADER*

*üì± Apk Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from playstore. üì≤',
buttonText: '*üî¢ Reply below number*',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})

cmd({
    pattern: "dapk",
    dontAddCommandList: true,
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
await conn.sendMessage(from, { react: { text: 'üì•', key: mek.key }})
if(!q) return await conn.sendMessage(from , { text: '*Need apk link...*' }, { quoted: mek } ) 
const data = await apkdl.download(q)
let sendapk = await conn.sendMessage(from , { document : { url : data.dllink  } , mimetype : 'application/vnd.android.package-archive' , fileName : data.name + '.' + 'apk',caption: '*·¥ã·¥Ä·¥†…™ ·¥áx·¥á‚Ä¢·¥ç·¥ú ü·¥õ…™-·¥Ö·¥á·¥†…™·¥Ñ·¥á*\n*·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥ã·¥Ä·¥†…™  ô·¥è è*' } , { quoted: mek })
await conn.sendMessage(from, { react: { text: 'üìÅ', key: sendapk.key }})
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
} catch (e) {
    reply('*ERROR !!*')
  l(e)
}
})

cmd({
    pattern: "apkinfo",
    dontAddCommandList: true,
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    var msg = mek
await conn.sendMessage(from, { react: { text: '‚ÑπÔ∏è', key: msg.key }})
if(!q) return await conn.sendMessage(from , { text: '*Need apk link...*' }, { quoted: msg } ) 
const data = await apkdl.download(q)
let listdata = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
*‚ïëü§≥ùôÜùòºùôëùôÑ PLAYSTORE-SEARCH*
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

*üìö ·¥Ä·¥ò·¥ò …¥·¥Ä·¥ç·¥á: ${data.name}* 

*üìà ·¥Ä·¥ò·¥ò Íú±…™·¥¢·¥á(·¥ç ô): ${data.size}*

*üì±  ü·¥ÄÍú±·¥õ ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö: ${data.lastup}*

*üì¶ ·¥Ö·¥á·¥†·¥á ü·¥è·¥ò·¥á Ä: ${data.package}* 

_*‚óØ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óØ*_`
await conn.sendMessage(from, { image: { url: data.icon }, caption: listdata }, { quoted: msg })
await conn.sendMessage(from, { react: { text: '‚úî', key: msg.key }})
} catch (e) {
  l(e)
}
})


//============================================================================
cmd({
    pattern: "ss",
    react: 'üñºÔ∏è',
    desc: "url to screenshot",
    category: "download",
    use: '.ss url',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let dat = `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]
   
 ‚ñè *SS CONVETER*

‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óâ`
  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'desktop ' + q , description: 'Desktop type ss'},
	    {title: "2", rowId: prefix + 'ssphone ' + q , description: 'Phone type ss üñºÔ∏è'} ,
	    {title: "3", rowId: prefix + 'sstab ' + q , description: 'Tab type ss üñºÔ∏è'} ,
            

	]
    } 
]   
  const listMessage = {
caption: dat,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})

	


cmd({
    pattern: "desktop",
    react: "üì∏",
    alias: ["screenshot","ssweb","ssdesktop"],
    desc: descg,
    category: "download",
    use: '.ss <url>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if(!q) return reply(imgmsg)
let name = getRandom('')
let data = await sswebA(q,true,'desktop')
fs.writeFileSync(name + '.jpg', data);
let dat = `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *üì∏ SCREENSHOT GETTER*`
const sections = [
    {
	title: "",
	rows: [
{title: "1", rowId: prefix + 'ssd ' + name + '.jpg', description: 'DOCUMENT'}, 
{title: "2", rowId: prefix + 'ssi ' + name + '.jpg', description: 'IMAGE'}, 
]
    } 
]
    const listMessage = {
caption: dat,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})

	
cmd({
    pattern: "ssphone",
    react: "üì∏",
    desc: descp,
    category: "download",
    use: '.ss <url>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if(!q) return reply(imgmsg)
let name = getRandom('')
let data = await sswebA(q,true,'phone')
fs.writeFileSync(name + '.jpg', data);
let dat = `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *üì∏ SCREENSHOT GETTER*`
const sections = [
    {
	title: "",
	rows: [
 {title: "1", rowId: prefix + 'ssd ' + name + '.jpg', description: 'DOCUMENT'},
 {title: "2", rowId: prefix + 'ssi ' + name + '.jpg', description: 'IMAGE'} ,
	]
    } 
]
    const listMessage = {
caption: dat,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})

cmd({
    pattern: "sstab",
    react: "üì∏",
    desc: desct,
    category: "download",
    use: '.ss <url>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if(!q) return reply(imgmsg)
let name = getRandom('')
let data = await sswebA(q,true,'tablet')
fs.writeFileSync(name + '.jpg', data);
let dat = `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *üì∏ SCREENSHOT GETTER*`
const sections = [
    {
	title: "",
	rows: [
 {title: "1", rowId: prefix + 'ssd ' + name + '.jpg', description: 'DOCUMENT'},
 {title: "2", rowId: prefix + 'ssi ' + name + '.jpg', description: 'IMAGE'} ,
	]
    } 
]
    const listMessage = {
caption: dat,
image : { url: config.LOGO },	
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})

	    
cmd({
  pattern: "ssi",
  dontAddCommandList: true,
  filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
await conn.sendMessage(from, { react: { text: 'üì•', key: mek.key }})
await conn.sendMessage(from, { image: fs.readFileSync(q), caption: config.FOOTER }, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
} catch (e) {
  reply('*ERROR !!*')
l(e)
}
})

cmd({
  pattern: "ssd",
  dontAddCommandList: true,
  filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
await conn.sendMessage(from, { react: { text: 'üì•', key: mek.key }})
await conn.sendMessage(from, { document: fs.readFileSync(q), mimetype: 'image/jpeg', fileName: 'screenshot' + '.jpg',caption: config.FOOTER  }, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
} catch (e) {
  reply('*ERROR !!*')
l(e)
}
})



cmd({
    pattern: "mediafire",
    alias: ["mfire"],
    desc: "download mfire files",
    category: "download",
    react: "üì©",
    filename: __filename
},
async(conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q && !q.startsWith("https://")) return reply("give me mediafire url")
        //fetch data from api  

const response = await require("undici").fetch(q);
            const data = await response.text();
            const $ = cheerio.load(data);
            
            let name = $('.dl-info > div > div.filename').text();
            let dl_link = $('#downloadButton').attr('href');
            let det = $('ul.details').html().replace(/\s/g, "").replace(/<\/li><li>/g, '\n').replace(/<\/?li>|<\/?span>/g, '');
            let type = $('.dl-info > div > div.filetype').text();
            let size = $('body > main > div.content > div.center > div > div.dl-info > ul > li:nth-child(1) > span').text()
            let date = $('body > main > div.content > div.center > div > div.dl-info > ul > li:nth-child(2) > span').text()

            var fileType = ''

            if(name.includes(".zip")) { fileType = "application/zip"
            } else if (name.includes(".pdf")) { fileType = "application/pdf" 
            } else if (name.includes(".mp4")) { fileType = "video/mp4" 
            } else if (name.includes(".mkv")) { fileType = "video/mkv"
            } else if (name.includes(".mp3")) { fileType = "audio/mpeg"
            } else if (name.includes(".7z")) { fileType = "application/x-7z-compressed"
            } else if (name.includes("jpg" || "jpeg")) { fileType = "image/jpeg"
            } else if (name.includes(".png")) { fileType = "image/png"
            } else if (name.includes(".rar")) { fileType = "application/x-rar-compressed"
            } else { fileType = "application/octet-stream" }




        reply("*ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MEDIAFIRE FILE DOWNLOADING...üì•*")
        await conn.sendMessage(from, { document: { url: dl_link }, fileName: name, mimetype: fileType, caption: `${name}\n\n${type}\n\n${size}\n\n${date}` }, { quoted: mek })                                                                                                                 
    } catch (e) {
        console.log(e)
        reply(`${e}`)
    }
})



cmd({
    pattern: "ig",
    alias: ["igstory"],
    react: 'üéÄ',
    desc: "Download instagram videos/photos.",
    category: "download",
    use: '.ig <Instagram link>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
 if (!q) return await  reply(needus)
  let response = await fetchJson('https://api.maher-zubair.tech/download/instagram2?url='+q)
  for (let i=0;i<response.data.data.length;i++) {
    if(response.data.data[i].type === 'image') await conn.sendMessage(from, { image: { url: response.data.data[i].url }, caption: config.FOOTER}, { quoted: mek })
  else await conn.sendMessage(from, { video: { url: response.data.data[i].url }, caption: config.FOOTER}, { quoted: mek })
  }
} catch (e) {
reply(cantf)
l(e)
}
})

cmd({
    pattern: "threads",
    alias: ["thread"],
    react: 'üßµ',
    desc: "Download threads videos/photos.",
    category: "download",
    use: '.threads <threads link>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
 if (!q) return await reply(needus)
  let response = await Download(q)
  for (let i=0;i<response.download.length;i++) {
    if(response.download[i].type === 'image') await conn.sendMessage(from, { image: { url: response.download[i].url }, caption: config.FOOTER}, { quoted: mek })
  else await conn.sendMessage(from, { video: { url: response.download[i].url }, caption: config.FOOTER}, { quoted: mek })
  }
} catch (e) {
reply(cantf)
l(e)
}
})

cmd({
    pattern: "pindl",
    react: "üîñ",
    desc: "download pinterest images",
    category: "download",
    use: '.pindl',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
                                                                   
                                  
                                  let { pinterest } = require('../lib/scraper')
                                  anu = await pinterest(q)
                                  result = anu[Math.floor(Math.random() * anu.length)]
                                  conn.sendMessage(mek.chat, { image: { url: result }, caption: 'üîÆ Media Url : '+result }, { quoted: mek })
await conn.sendMessage(from, { react: { text: `‚úÖ`, key: mek.key }}) 
} catch (e) {
reply()
l(e)
}
})






cmd({
    pattern: "gdrive",
    alias: ["googledrive'"],
    react: 'üìë',
    desc: "Download googledrive files.",
    category: "download",
    use: '.gdrive <googledrive link>',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  if (!q) return await  reply('*Please give me googledrive url !!*')   
let res = await GDriveDl(q)
		let txt = `*[ Downloading file ]*\n\n`
		txt += `*Name :* ${res.fileName}\n`
		txt += `*Size :* ${res.fileSize}\n`
		txt += `*Type :* ${res.mimetype}`	
        await reply(txt)
conn.sendMessage(from, { document: { url: res.downloadUrl }, fileName: res.fileName, mimetype: res.mimetype }, { quoted: mek })
} catch (e) {
reply('*Error !!*')
console.log(e)
//reply(${e})
}
})



//===============================TIKTOK COMMAND===============================

                                         
cmd({
    pattern: "tiktok",
    alias: ["ttdl","tt"],
    react: 'üè∑Ô∏è',
    desc: desc,
    category: "download",
    use: '.tiktok <Tiktok link>',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!regtik(q)) return await  reply(urlneed)

let result = await downloadTiktok(q);

let dat = `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

*TIKTOK DOWNLOADER*

*üìÉ Title:* ${result.result.title}
*‚úçüèº Link:* ${q}`

const sections = [
    {
	title: "Watermark-01",
	rows: [
	{title: "    1.1", rowId: `${prefix}tn1 ${q}`,description: 'No-Watermark-01'},
        {title: "    1.2", rowId: `${prefix}tn1d ${q}`,description: 'No-Watermark-01 Doc'},
	]
    },
	{
	title: "Watermark-02",
	rows: [	
        {title: "    2.1", rowId: `${prefix}tn2 ${q}`,description: 'No-Watermark-02'},
        {title: "    2.2", rowId: `${prefix}tn2d ${q}`,description: 'No-Watermark-02 Doc'},
	]
    },
	{
	title: "Watermark-HD",
	rows: [	
        {title: "    3.1", rowId: `${prefix}thd ${q}`,description: 'No-Watermark-HD'} ,
        {title: "    3.2", rowId: `${prefix}tndd ${q}`,description: 'No-Watermark-HD Doc'},      
	]
    },
	{	
	title: "VOICE CUT TYPE üé∂",
	rows: [	
	{title: "    4.1", rowId: `${prefix}ta ${q}`,description: 'AUDIO DOWNLOAD'} ,
	{title: "    4.2", rowId: `${prefix}td ${q}`,description: 'DOCUMENT DOWNLOAD'} ,	
  ]
    } 
]
	
const listMessage = {
image: { url: result.result.image },	
caption: dat,
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})





cmd({
    pattern: "thd",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

  //let data = await fetchJson(`${baseUrl}/api/tiktokdl?url=${q}`)
let data = await downloadTiktok(q);

    

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { video: { url: data.result.dl_link.download_mp4_hd }, mimetype: "video/mp4", caption: `> *POWERED by VAJIRA-MD*` }, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})



cmd({
    pattern: "thdd",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

  //let data = await fetchJson(`${baseUrl}/api/tiktokdl?url=${q}`)
let data = await downloadTiktok(q);

    

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { document: { url: data.result.dl_link.download_mp4_hd }, mimetype: "video/mp4", fileName: `${data.result.title}.mp4`, caption: "üíª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ TTDL*" }, { quoted: mek }); 
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})


cmd({
    pattern: "tn2",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
 
let data = await downloadTiktok(q);

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { video: { url: data.result.dl_link.download_mp4_1}, mimetype: "video/mp4", caption: `> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*` }, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})



cmd({
    pattern: "tn2d",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
 
let data = await downloadTiktok(q);

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { document: { url: data.result.dl_link.download_mp4_1 }, mimetype: "video/mp4", fileName: `${data.result.title}.mp4`, caption: "üíª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ TTDL*" }, { quoted: mek }); 
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})

cmd({
    pattern: "tn1",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  
 

 // let data = await fetchJson(`${baseUrl}/api/tiktokdl?url=${q}`)
let data = await downloadTiktok(q);

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { video: { url: data.result.dl_link.download_mp4_2 }, mimetype: "video/mp4", caption: `> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*` }, { quoted: mek })  
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})





cmd({
    pattern: "tn1d",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  
 

 // let data = await fetchJson(`${baseUrl}/api/tiktokdl?url=${q}`)
let data = await downloadTiktok(q);

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { document: { url: data.result.dl_link.download_mp4_2 }, mimetype: "video/mp4", fileName: `${data.result.title}.mp4`, caption: "üíª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*" }, { quoted: mek }); 
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})





cmd({
    pattern: "ta",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  


//  let data = await fetchJson(`${baseUrl}/api/tiktokdl?url=${q}`)
let data = await downloadTiktok(q);


await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { audio: { url: data.result.dl_link.download_mp3 }, mimetype: "audio/mpeg" }, { quoted: mek })  
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})



cmd({
    pattern: "td",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  


//  let data = await fetchJson(`${baseUrl}/api/tiktokdl?url=${q}`)
let data = await downloadTiktok(q);


await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { document: { url: data.result.dl_link.download_mp3 }, mimetype: "audio/mpeg", fileName: `${data.result.title}.mp3`, caption: "üíª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ TTDL*" }, { quoted: mek }); 
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})

cmd({
    pattern: "tiktok2",
    alias: ["ttdl2","tt2"],
    react: 'üè∑Ô∏è',
    desc: desc,
    category: "download",
    use: '.tiktok <Tiktok link>',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!regtik(q)) return await  reply(urlneed)
let data = await downloadTiktok(q);	
let msg = `
    üéüÔ∏è *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ TIKTOK DOWNLOADER* üéüÔ∏è

üìå *Please click what you want to select*

*Title* :- ${data.result.title}

*URL:* ${q}`	
await conn.sendMessage( from, { image: { url:`${data.result.image}`}, caption: msg }, { quoted: mek })	
await conn.sendMessage(from, { react: { text: 'üì•', key: mek.key }})
await conn.sendMessage(from, { document: { url: q }, mimetype: 'audio/mpeg', fileName: 'TikTok Audio' + '.mp3',caption: config.FOOTER }, { quoted: mek })
await conn.sendMessage(from, { video: { url: data.result.dl_link.download_mp4_1}, mimetype: "video/mp4", caption: `SD QUALITY\n\n> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ` }, { quoted: mek })	
await conn.sendMessage(from, { video: { url: data.result.dl_link.download_mp4_2 }, mimetype: "video/mp4", caption: `HD QUALITY\n\n> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ` }, { quoted: mek })  
	
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
} catch (e) {
  reply('*ERROR !!*')
l(e)
}
})






//================================IMG COMMAND======================================


	
cmd({
    pattern: "img1",
    react: 'üñºÔ∏è',
    desc: desc2,
    category: "",
    use: '.img2 car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await unsplash.search({"query": q, page: 1})
let data = results
if (data.result.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < data.length; i++) {
srh.push({
title: i + 1,
description: 'Image number: ' + nombor++ ,
rowId: prefix + 'dimg ' + data.result[i]
});
}
const sections = [{
title: "Result from unsplash.com. üì≤",
rows: srh
}]
const listMessage = { 
text: `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *IMG DOWNLOADER 02*

*üñºÔ∏è Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from unsplash.com. üì≤',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "img2",
    react: 'üñºÔ∏è',
    desc: desc3,
    category: "",
    use: '.img3 car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await pixabay.search({"query": q, page: 1})
let data = results
if (data.result.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < data.length; i++) {
srh.push({
title: i + 1,
description: 'Image number: ' + nombor++ ,
rowId: prefix + 'dimg ' + data.result[i]
});
}
const sections = [{
title: "Result from pixabay.com. üì≤",
rows: srh
}]
const listMessage = { 
text: `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *IMG DOWNLOADER 03*

*üñºÔ∏è Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from pixabay.com. üì≤',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "img3",
    react: 'üñºÔ∏è',
    desc: desc4,
    category: "",
    use: '.img4 car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await fetchJson('https://api.akuari.my.id/search/bingimage?query=' + q)
let data = results.hasil
if (data.results.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < data.length; i++) {
srh.push({
title: i + 1,
description: data.results[i].title ,
rowId: prefix + 'dimg ' + data.results[i].direct
});
}
const sections = [{
title: "Result from bing üì≤",
rows: srh
}]
const listMessage = { 
text: `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *IMG DOWNLOADER 04*

*üñºÔ∏è Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from bing üì≤',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "img4",
    react: 'üñºÔ∏è',
    desc: desc5,
    category: "download",
    use: '.img car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await gis(q);
let data = results.slice(0, 100)
if (data.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < data.length; i++) {
srh.push({
title: i + 1,
description: 'Image number: ' + nombor++ ,
rowId: prefix + 'dimg ' + data[i].url
});
}
const sections = [{
title: "Result from google. üì≤",
rows: srh
}]
const listMessage = { 
text: `[üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑]

   *IMG DOWNLOADER 01*

*üñºÔ∏è Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from google. üì≤',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "dimg",
    dontAddCommandList: true,
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    await conn.sendMessage(from, { react: { text: 'üîÉ', key: mek.key }})
    await conn.sendMessage(from, { image: { url: q }, caption: config.FOOTER }, { quoted: mek })
    await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
} catch (e) {
    reply(errt)
  l(e)
}
})



cmd({
    pattern: "wallpaper",
    react: "üîñ",
    desc: "image downloader",
    category: "download",
    use: '.wallpaper',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    let teks = 'Enter Query Title'
        let { wallpaper } = require('../lib/scraper')
                                  anu = await wallpaper(q)
                                  result = anu[Math.floor(Math.random() * anu.length)]
                          
              const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'wallpaper ' + q , description: 'NEXT  PIC ‚û°Ô∏è'},

	]
    } 
]      
                                  const listMessage = {
  image: { url: result.image[0] },
      caption: `üîÆ ùóßùóúùóßùóüùóò : ${result.title}\nüîÆ ùóñùóîùóßùóòùóöùó¢ùó•ùó¨ : ${result.type}\nüîÆ ùóóùóòùóßùóîùóúùóü : ${result.source}\nüîÆ ùó†ùóòùóóùóúùóî ùó®ùó•ùóü : ${result.image[2] || result.image[1] || result.image[0]}`,
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})

cmd({
    pattern: "wikimedia",
    react: "üîñ",
    desc: "to download wikimedia",
    category: "download",
    use: '.wikimedia',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    let teks = 'Enter Query Title'
    let { wikimedia } = require('../lib/scraper')
                                  anu = await wikimedia(q)
                                  result = anu[Math.floor(Math.random() * anu.length)]
                                  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'wikimedia ' + q , description: 'NEXT  PIC ‚û°Ô∏è'},

	]
    } 
]      
                                  const listMessage = {
 image: { url: result.image[0] },
      caption: `üîÆ ùóßùóúùóßùóüùóò : ${result.title}\nüîÆ ùóñùóîùóßùóòùóöùó¢ùó•ùó¨ : ${result.type}\nüîÆ ùóóùóòùóßùóîùóúùóü : ${result.source}\nüîÆ ùó†ùóòùóóùóúùóî ùó®ùó•ùóü : ${result.image[2] || result.image[1] || result.image[0]}`,
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})



cmd({
    pattern: "quotesanime",
    react: "üîñ",
    desc: "to download animes",
    category: "download",
    use: '.quotesanime',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    let teks = 'Enter Query Title'
         let { quotesAnime } = require('../lib/scraper')
                                  let anu = await quotesAnime()
                                  result = anu[Math.floor(Math.random() * anu.length)]
                                  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'quotesanime ' + q , description: 'NEXT  PIC ‚û°Ô∏è'}

	]
    } 
]      
                                  const listMessage = {
 text: `~_${result.quotes}_\n\nBy '${result.karakter}', ${result.anime}\n\n- ${result.up_at}`,
                                      footer: config.FOOTER,
                                      buttonText: "üî¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'üí´ ùôÜ ùòº ùôë ùôÑ   ùôÄùôìùôÄ üêãü©∑',
					body: '·¥Ä…¥ ·¥úÍú±·¥á Ä  ô·¥è·¥õ Íú∞·¥è Ä ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/4dbd5c70979a2d6ff7ef9-37c24f77e802ed43d7.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}
 
return await conn.replyList(from, listMessage ,{ quoted : mek }) 
} catch (e) {
reply(N_FOUND)
l(e)
}
})



cmd({
    pattern: "coffe",
    react: "üîñ",
    desc: "to download coffe",
    category: "download",
    use: '.coffe',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    await conn.sendMessage(from, { react: { text: `‚òï`, key: mek.key }})
                              const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'coffe ' + q , description: 'NEXT  PIC ‚û°Ô∏è'}

	]
    } 
]      
                                  const listMessage = {
 image: { url: 'https://coffee.alexflipnote.dev/random' },
caption: `Random Coffee`,
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})


cmd({
    pattern: "wpaper",
    react: "üîñ",
    desc: "to download wpaper",
    category: "download",
    use: '.wpaper',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  let teks = '*LOADING...*'
    await conn.sendMessage(mek.chat, { image: { url: `https://api.akuari.my.id/search/alphacoders?query=${q}` },  caption: `${config.cap}`}, { quoted: mek }),
   await conn.sendMessage(mek.chat, { image: { url: `https://api.akuari.my.id/search/alphacoders?query=${q}` },  caption: `${config.cap}`}, { quoted: mek }.repeat(5))
await conn.sendMessage(from, { react: { text: `‚úÖ`, key: mek.key }}) 
} catch (e) {
reply()
l(e)
}
})


cmd({
    pattern: "ringtone",
    react: "üîñ",
    desc: "to download ringtone",
    category: "download",
    use: '.ringtone',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) reply `${Lang.EXAMPLE}\n : ${prefix + command} black rover`
                          let { ringtone } = require('../lib/scraper')
                          let anu = await ringtone(q)
                          let result = anu[Math.floor(Math.random() * anu.length)]
                          conn.sendMessage(mek.chat, { audio: { url: result.audio }, fileName: result.title+'.mp3', mimetype: 'audio/mpeg' }, { quoted: mek })
await conn.sendMessage(from, { react: { text: `‚úÖ`, key: mek.key }}) 
} catch (e) {
reply()
l(e)
}
})



cmd({
    pattern: "couplepp",
    react: "üîñ",
    desc: "couple pic download",
    category: "download",
    use: '.couplepp',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
   await conn.sendMessage(from, { react: { text: `üíè`, key: mek.key }})
                                  
                                  let anu = await fetchJson('https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json')
                                  let random = anu[Math.floor(Math.random() * anu.length)]
                                  conn.sendMessage(mek.chat, { image: { url: random.male }, caption: `Couple Male` }, { quoted: mek })
                                  conn.sendMessage(mek.chat, { image: { url: random.female }, caption: `Couple Female` }, { quoted: mek })
                              
                               
                              await conn.sendMessage(from, { react: { text: `‚úÖ`, key: mek.key }}) 
} catch (e) {
reply()
l(e)
}
})       




//===================================FB COMMAND====================================
    
cmd({
  pattern: "fb",
  react: '#Ô∏è‚É£',
  alias: ["fbdl","facebook"],
  desc: desc1,
  category: "download",
  use: '.fb <Fb video link>',
  filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!fbreg(q)) return await  reply(urlneed2)	
const result = await facebook(q)	
let dat = `ùôÜùòºùôëùôÑ ùôÄùôìùôÄ FB DOWNLOADER

   
*TIME :* ${result.result.duration}
*URL :* ${q}`

var sections = [
    {
	title: "SD TYPE ü™´",
	rows: [
  {title: "    1.1", rowId: prefix + 'fbsd ' + q, description: ' ü™´ `SD` QUALITY VIDEO'}, 
  {title: "    1.2", rowId: prefix + 'fbsdd ' + q, description: ' üìÇ `SD` QUALITY DOCUMENT'},	
]
    },
{
	title: "HD TYPE üîã",
	rows: [
  {title: "    2.1", rowId: prefix + 'fbhd ' + q, description: ' üîã `HD` QUALITY VIDEO'}, 
  {title: "    2.2", rowId: prefix + 'fbhdd ' + q, description: ' üìÇ `HD` QUALITY DOCUMENT'},		
]
},
{
	title: "VOICE CUT TYPE üé∂",
	rows: [
  {title: "    3.1", rowId: prefix + 'fba ' + q, description: ' üé∂ Audio file'},	
  {title: "    3.2", rowId: prefix + 'fbd ' + q, description: ' üìÇ Document file'}			
]
    } 

]
const listMessage = {
image: { url:`${result.result.thumbnail}`},
caption: dat,
footer: config.FOOTER,
title: '',
buttonText: '*üî¢ Reply below number*',
sections
}
return await conn.replyList(from, listMessage ,{ quoted : mek })
} catch (e) {
  reply('*ERROR !!*')
  l(e)
}
})




cmd({
  pattern: "fb2",
  react: '#Ô∏è‚É£',
  alias: ["fbdl2","facebook2"],
  desc: desc1,
  category: "download",
  use: '.fb <Fb video link>',
  filename: __filename
},
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

if (!fbreg(q)) return await  reply(urlneed2)

 // let data = await fetchJson(`${baseUrl}/api/fdown?url=${q}`)
const result = await facebook(q)
const info = `
üí¢ *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ FB DOWNLOADER* üí¢

*TIME :* ${result.result.duration}
*URL :* ${q}
`	
await conn.sendMessage(from, { image: { url:`${result.result.thumbnail}`}, caption: info } , { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { audio: { url: result.result.links.HD }, mimetype: "audio/mpeg" }, { quoted: mek })	
await conn.sendMessage(from, { video: { url: result.result.links.SD }, mimetype: "video/mp4", caption: `SD QUALITY\n\n> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*` }, { quoted: mek })  
await conn.sendMessage(from, { video: { url: result.result.links.HD }, mimetype: "video/mp4", caption: `HD QUALITY\n\n> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*` }, { quoted: mek })  	
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})



cmd({
    pattern: "fbsd",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

 

 // let data = await fetchJson(`${baseUrl}/api/fdown?url=${q}`)
const result = await facebook(q)

	
await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { video: { url: result.result.links.SD }, mimetype: "video/mp4", caption: `> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*` }, { quoted: mek })  
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})


cmd({
    pattern: "fbsdd",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

 

 // let data = await fetchJson(`${baseUrl}/api/fdown?url=${q}`)
const result = await facebook(q)

	
await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { document: { url: result.result.links.SD }, mimetype: "video/mp4", fileName: `FbDL.mp4`, caption: "üíª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ MD FBDL*" }, { quoted: mek })	
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})


cmd({
    pattern: "fbhd",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  
if (!q.includes('https://')) return await reply(msr.not_fo)

 // let data = await fetchJson(`${baseUrl}/api/fdown?url=${q}`)
const result = await facebook(q)

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { video: { url: result.result.links.HD }, mimetype: "video/mp4", caption: `> *POWERED by ùôÜùòºùôëùôÑ ùôÄùôìùôÄ*` }, { quoted: mek })  	
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})


cmd({
    pattern: "fbhdd",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  
if (!q.includes('https://')) return await reply(msr.not_fo)

 // let data = await fetchJson(`${baseUrl}/api/fdown?url=${q}`)
const result = await facebook(q)

await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})  
await conn.sendMessage(from, { document: { url: result.result.links.HD }, mimetype: "video/mp4", fileName: `FbDL.mp4`, caption: "üíª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ FBDL*" }, { quoted: mek }); 
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})


					    
cmd({
    pattern: "fba",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  

if (!q.includes('https://')) return await reply(msr.not_fo)

//let data = await fetchJson(`${baseUrl}/api/fdown?url=${q}`)
const result = await facebook(q)

	
await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { audio: { url: result.result.links.HD }, mimetype: "audio/mpeg" }, { quoted: mek })
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})


cmd({
    pattern: "fbd",
    react: "‚¨á",    
    filename: __filename
},

async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  

if (!q.includes('https://')) return await reply(msr.not_fo)

//let data = await fetchJson(`${baseUrl}/api/fdown?url=${q}`)
const result = await facebook(q)

	
await conn.sendMessage(from, { react: { text: '‚¨Ü', key: mek.key }})
await conn.sendMessage(from, { document: { url: result.result.links.HD }, mimetype: "audio/mpeg", fileName: `Fbdl.mp3`, caption: "üíª *ùôÜùòºùôëùôÑ ùôÄùôìùôÄ Fbdl*" }, { quoted: mek }); 
await conn.sendMessage(from, { react: { text: '‚úî', key: mek.key }})
}catch(e){
await conn.sendMessage(from, { react: { text: `‚ùå`, key: mek.key } })
console.log(e)
reply(`Error !!\n\n*${e}*`)
}
})